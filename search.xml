<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>React学习笔记</title>
      <link href="/posts/3cba66fa.html"/>
      <url>/posts/3cba66fa.html</url>
      
        <content type="html"><![CDATA[<div class="note info flat"><p>前言: 在较早之前写过几个React的项目，用的是老版本的React，当时觉得React的类组件写法太麻烦了相比之下Vue的写法就简便很多了，于是转向了Vue。然而作为一个前端，React也是一门必会的技术，正巧随着React18的发布也转向了函数式，听说写法比以前舒服太多了，于是果断来重新学习。</p></div><h2 id="什么是React？"><a href="#什么是React？" class="headerlink" title="什么是React？"></a>什么是React？</h2><p><strong>React</strong>是一个构建用户界面的 JavaScript 库(框架)，用来为现代的网络构建用户界面(UI)。它由Facebook的软件工程师 Jordan Walke 开发，2012年部署于 Instagram，2013年开源。除此之外，React还有React Native框架，通过它让我们可以直接使用 JavaScript 来编写原生应用。以及支持服务端渲染(SSR)，以获得更好的SEO优化。</p><p>React的特点:</p><ul><li>虚拟DOM</li><li>声明式</li><li>组件化</li><li>单项数据流</li><li>diff算法</li><li>JSX、TSX语法</li><li>支持服务器端渲染</li><li>社区丰富</li></ul><h2 id="一个简单使用React例子"><a href="#一个简单使用React例子" class="headerlink" title="一个简单使用React例子"></a>一个简单使用React例子</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>1-demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- react核心库，只要使用react就必须要引入 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react@18.2.0/umd/react.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- react的dom包，使用react开发web应用时必须引入 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react-dom@18.2.0/umd/react-dom.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 通过操作dom创建元素</span></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">/*       const div = document.createElement(&#x27;div&#x27;);</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">      div.innerText = &#x27;我是一个div&#x27;;</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">      const root = document.getElementById(&#x27;root&#x27;);</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">      root.appendChild(div); */</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// react方式创建元素</span></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// createElement参数：1.元素名 2.元素属性配置对象 3.内容</span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> div = <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>, &#123;&#125;, <span class="string">&#x27;我是一个div&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> root = <span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>));</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      root.<span class="title function_">render</span>(div);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="三个API"><a href="#三个API" class="headerlink" title="三个API"></a>三个API</h3><ul><li><code>React.createElement()</code><ul><li><code>React.createElement(type, [props], [...children])</code></li><li>用来创建React元素</li><li>创建的React元素无法修改，只能通过替换的方式修改</li></ul></li><li><code>ReactDOM.createRoot()</code><ul><li><code>createRoot(container[, options])</code></li><li>用来创建React的根容器，容器用来放置React元素</li></ul></li><li><code>root.render()</code><ul><li><code>root.render(element)</code></li><li>当首次调用时，容器节点里的所有 DOM 元素都会被替换，后续的调用则会使用 React 的 DOM 差分算法（DOM diffing algorithm）也就是diff算法进行高效的更新。</li><li>不会修改容器节点（只会修改容器的子节点）。可以在不覆盖现有子节点的情况下，将组件插入已有的 DOM 节点中。</li></ul></li></ul><h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h2><p>JSX 是 JavaScript 的语法扩展，JSX 使得我们可以以类似于 HTML 的形式去使用 JS。JSX便是React中声明式编程的体现方式。我们可以通过JSX来描述网页结构，然后React会根据JSX自动生成对应的JS代码。也就是说编写的JSX代码，最终都会转换为以调用<code>React.createElement()</code>创建元素的代码。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react@18.2.0/umd/react.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react-dom@18.2.0/umd/react-dom.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/babel-standalone@6/babel.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/babel&quot;</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">  const div = (</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">    <span class="tag">&lt;<span class="name">div</span></span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="language-handlebars">      <span class="attr">id</span>=<span class="string">&quot;root&quot;</span></span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="language-handlebars">      <span class="attr">className</span>=<span class="string">&quot;box&quot;</span></span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="language-handlebars">      <span class="attr">style</span>=</span></span><span class="template-variable">&#123;&#123; <span class="name">backgroundColor:</span> <span class="string">&#x27;#bfc&#x27;</span>, border: <span class="string">&#x27;1px solid yellow&#x27;</span> &#125;&#125;</span><span class="language-xml"><span class="tag"></span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="language-handlebars">    &gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> alert(&#x27;哈哈哈&#x27;)&#125;&gt;我是一个按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">      <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">  );</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">  const root = ReactDOM.createRoot(document.getElementById(&#x27;root&#x27;));</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">  root.render(div);</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars"></span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当在浏览器中直接使用JSX时需要引入<strong>babel</strong>。</p><p>注意事项:</p><ol><li>JSX不需要加引号</li><li>只有一个根标签，与Vue2的模版类似</li><li>HTML标签必须以小写字母开头，React组件必须以大写字母开头</li><li>使用<strong>{}</strong>插入JS表达式(表达式：有返回值的语句。JSX也是表达式)</li><li>书写属性与原生HTML类似，但是class需要使用className，style必须使用<strong>{}</strong></li><li>JSX比HTML语法更加严格，标签必须闭合</li><li>布尔类型、Null 以及 Undefined 在<strong>{}</strong>中将会被忽略渲染</li></ol><h3 id="渲染条件"><a href="#渲染条件" class="headerlink" title="渲染条件"></a>渲染条件</h3><p>在JSX中不能使用<code>if</code>语句，并且也没有Vue中的<code>v-if v-elif v-else v-show</code>指令，渲染列表我们可以这样做:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/babel&quot;</span>&gt;</span><br><span class="line">  <span class="keyword">const</span> name = <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line">  <span class="keyword">const</span> lang = <span class="string">&#x27;cn&#x27;</span>;</span><br><span class="line">  <span class="keyword">let</span> div;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (lang === <span class="string">&#x27;cn&#x27;</span>) div = <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>你好, &#123;name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  <span class="keyword">else</span> div = <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello, &#123;name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> root = <span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>));</span><br><span class="line">  root.<span class="title function_">render</span>(div);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>或者使用三元表达式:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;lang === &#x27;cn&#x27; ? `你好,$&#123;name&#125;` : `Hello,$&#123;name&#125;`&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>);</span><br></pre></td></tr></table></figure><p>或者使用<code>&amp;&amp;</code>运算符。</p><h3 id="渲染列表"><a href="#渲染列表" class="headerlink" title="渲染列表"></a>渲染列表</h3><p>同样在JSX中不能使用<code>for</code>语句，并且也没有Vue中的<code>v-for</code>指令，渲染列表我们可以这样做:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/babel&quot;</span>&gt;</span><br><span class="line">  <span class="keyword">const</span> fruitList = [<span class="string">&#x27;苹果&#x27;</span>, <span class="string">&#x27;香蕉&#x27;</span>, <span class="string">&#x27;菠萝&#x27;</span>, <span class="string">&#x27;猕猴桃&#x27;</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> root = <span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>));</span><br><span class="line">  root.<span class="title function_">render</span>(</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;fruitList.map((item) =&gt; (</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;item&#125;</span>&gt;</span>&#123;item&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      ))&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>在JSX中会自动展开数组，我们只需要保证数组中是一个个的JSX表达式即可。<code>key=&#123;item&#125;</code>与Vue中的<code>:key=&quot;xxx&quot;</code>相同都是用于diff比较算法，来减少不必要的渲染。</p><h2 id="虚拟DOM与DIFF算法"><a href="#虚拟DOM与DIFF算法" class="headerlink" title="虚拟DOM与DIFF算法"></a>虚拟DOM与DIFF算法</h2><h3 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h3><p>当我们通过 React 操作DOM时，比如通过 <code>React.createElement()</code> 创建元素时。所创建的元素并不是真正的DOM对象而是React元素。React元素是React应用的最小组成部分，通过JSX所创建的元素都属于React元素。与浏览器的 DOM 元素不同，React 元素就是一个普通的JS对象，且创建的开销极小。</p><p>React元素不是DOM对象，那为什么可以被添加到页面中去呢？实际上每个React元素都会有一个对应的DOM元素，对React元素的所有操作，最终都会转换为对DOM元素操作，也就是所谓的虚拟DOM。虚拟DOM就好似真实DOM的代理，对React元素的操作最终都会映射到真实的DOM元素上。</p><p>虚拟DOM相较于直接操作原生DOM的优点：</p><ul><li>虚拟DOM简化了DOM操作，原生的DOM操作API非常的多也非常的杂。</li><li>解决DOM的兼容性问题，不同的浏览器之间操作DOM的方法是不同的，特别是IE。这里只需操作虚拟DOM，其他的交给React即可。</li><li>综合情况下性能更好。为什么怎么说呢？我们在操作原生DOM的情况下，很有可能会进行不必要的DOM操作增加性能消耗。而虚拟DOM，引入了diff算法，减少DOM的操作，从而提升了性能。</li></ul><h3 id="DIFF算法"><a href="#DIFF算法" class="headerlink" title="DIFF算法"></a>DIFF算法</h3><p>diff算法会在元素之间进行比较，然后只会对DOM做必要的更新来呈现结果。简单来说，就是拿新建的元素和旧的元素进行比较，只对发生变化的部分对DOM进行更新，减少DOM的操作，从而提升了性能。</p><p>渲染列表就是使用了diff算法。它需要指定一个key，不指定将会报错。默认情况下会使用索引当作key，即使不指定key，这也是为什么即使报错也不会影响使用。然而使用索引当作key是有问题的，因为一旦向数组最前面插入数据，整个索引就会依次发生改变，key也就发生了变化，从而导致整个列表重新渲染，即使数组中后续的元素并没有发生改变。因此要确保key的唯一性。另外不同的列表之间key不会影响。</p><h2 id="创建React项目"><a href="#创建React项目" class="headerlink" title="创建React项目"></a>创建React项目</h2><p>在开发React项目过程中使用上面网页引入的方式显然不靠谱，我们可以使用包管理器(npm，yarn，pnpm)来管理我们的项目并且React官方为了方便我们的开发，为我们提供react-scripts包。包中提供了项目开发中的大部分依赖，大大的简化了项目的开发。</p><p>首先创建文件夹并且初始化项目，这里使用<strong>pnpm</strong>来管理项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm init</span><br></pre></td></tr></table></figure><p>安装相关依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm add react react-dom react-scripts</span><br></pre></td></tr></table></figure><p>创建目录及文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root</span><br><span class="line">    - public</span><br><span class="line">        - index.html （添加标签 &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;）</span><br><span class="line">    - src</span><br><span class="line">        - App.js</span><br><span class="line">        - index.js</span><br><span class="line">    - package.json</span><br><span class="line">    - pnpm-lock.yaml</span><br></pre></td></tr></table></figure><p>在<strong>package.json</strong>中添加</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="string">&quot;react-scripts start&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;react-scripts build&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>index.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>React-Project<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>app.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello React!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure><p>index.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom/client&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./app&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> root = <span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>));</span><br><span class="line"></span><br><span class="line">root.<span class="title function_">render</span>(<span class="title class_">App</span>());</span><br></pre></td></tr></table></figure><h3 id="Create-React-App"><a href="#Create-React-App" class="headerlink" title="Create-React-App"></a>Create-React-App</h3><p>上面的创建流程还是显得有些繁琐，当然React还提供了<strong>Create-React-App</strong>脚手架，只需一条命令搞定</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx create-react-app my-app</span><br></pre></td></tr></table></figure><h2 id="React组件"><a href="#React组件" class="headerlink" title="React组件"></a>React组件</h2><p>现代构建web页面的框架都有组件的概念如Vue，组件就是把一个大页面拆分成一个个的小模块，已达到复用和更好的维护目的。</p><p>在React中组件有两种写法函数组件和类组件，React推荐使用函数组件，Vue则是单文件组件</p><h3 id="函数组件"><a href="#函数组件" class="headerlink" title="函数组件"></a>函数组件</h3><p>App.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello React!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure><p>index.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&quot;react-dom/client&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&quot;./App&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> root = <span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>));</span><br><span class="line">root.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span>/&gt;</span></span>);</span><br></pre></td></tr></table></figure><p>直接在<code>render</code>中以JSX的形式传入即可。</p><p>函数式组件主要有两个注意点：</p><ol><li>函数名首字母大写</li><li>返回值是一个JSX</li></ol><h3 id="类组件"><a href="#类组件" class="headerlink" title="类组件"></a>类组件</h3><p>类组件写起来比函数组件跟麻烦，并且官方更推荐函数组件</p><p>App.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 需要一个render函数返回一个JSX</span></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello React!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure><p>index.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom/client&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> root = <span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>));</span><br><span class="line"></span><br><span class="line">root.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span>/&gt;</span></span>);</span><br></pre></td></tr></table></figure><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>React中的事件处理类似于在HTML标签中通过属性来设置事件，像是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onclick=&quot;alert(&#x27;你点我干嘛&#x27;);&quot;&gt;点我一下&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>这是传统DOM中绑定事件的方式之一，onclick全都小写是事件的名字，它的值是一组JS代码，当事件触发时，JS代码便会执行。</p><p>React中的事件绑定是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">clickHandler</span> = (<span class="params"></span>)=&gt; &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;你点我干嘛&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> ele = <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;clickHandler&#125;</span>&gt;</span>我是一个按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure><p>两者长得很像，但是也有很大的区别：</p><ol><li>React事件使用的是驼峰命名法</li><li>事件属性值需要的是一个函数对象，而不是调用函数</li></ol><h3 id="事件对象-envent"><a href="#事件对象-envent" class="headerlink" title="事件对象(envent)"></a>事件对象(envent)</h3><p>React事件也会产生事件对象，在事件的响应函数中可以定义第一个参数来获取事件对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">clickHandler</span> = (<span class="params">e</span>)=&gt; &#123;</span><br><span class="line">    <span class="comment">// e 表示事件对象</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;你点我干嘛&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个事件对象是由React所创建的事件对象，和原生的事件对象类似，但使用它我们不需要担心兼容的问题。使用事件对象可以完成像原生DOM中事件对象的各种操作，比如取消默认行为和取消事件的冒泡：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">clickHandler</span> = (<span class="params">e</span>)=&gt; &#123;</span><br><span class="line">    e.<span class="title function_">preventDefault</span>(); <span class="comment">// 取消默认行为</span></span><br><span class="line">    e.<span class="title function_">stopPropagation</span>(); <span class="comment">// 取消事件的传播</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><p>和Vue中相似都是用于父组件给子组件传值</p><p>父组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Logs</span> <span class="keyword">from</span> <span class="string">&#x27;./components/Logs/Logs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Logs</span> <span class="attr">title</span>=<span class="string">&#x27;学习React&#x27;</span> <span class="attr">minute</span>=<span class="string">&#123;80&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure><p>子组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">LogDate</span> <span class="keyword">from</span> <span class="string">&#x27;./LogDate&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;../../css/logs.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Logs</span> = (<span class="params">props</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(props);</span><br><span class="line">  <span class="keyword">const</span> &#123; title, minute &#125; = props;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;log&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">LogDate</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;log-desc&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;title&quot;</span>&gt;</span>&#123;title&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;minute&quot;</span>&gt;</span>&#123;minute&#125;分钟<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Logs</span>;</span><br></pre></td></tr></table></figure><p>只需要在子组件中定义一个参数即可获取，通常这个参数我们会命名为props。</p><p>另外标签体也可以设置为props的一个属性，叫做children，可以通过props.children来获取标签体的内容。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">--父组件</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">Logs</span> <span class="attr">title</span>=<span class="string">&#x27;学习React&#x27;</span> <span class="attr">minute</span>=<span class="string">&#123;80&#125;</span>&gt;</span>哈哈哈<span class="tag">&lt;/<span class="name">Logs</span>&gt;</span></span></span><br><span class="line">    &lt;/&gt;</span><br><span class="line">   </span><br><span class="line">--子组件</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Logs</span> = (<span class="params">props</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(props);</span><br><span class="line">  <span class="keyword">const</span> &#123; title, minute &#125; = props;</span><br><span class="line">  <span class="keyword">const</span> &#123; children &#125; = props;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(children); <span class="comment">// 哈哈哈</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;log&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">LogDate</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;log-desc&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;title&quot;</span>&gt;</span>&#123;title&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;minute&quot;</span>&gt;</span>&#123;minute&#125;分钟<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意：props是只读的！</p><h2 id="State"><a href="#State" class="headerlink" title="State"></a>State</h2><p>props是不可变的，但在开发过程中我们是希望页面是随着数据而改变的，就好比Vue中的响应式(data中的数据，ref、reactive包装的数据)。React中可以使用state。</p><p>state只属于当前组件，其他组件无法访问。并且state是可变的，当其发生变化后组件会自动重新渲染。</p><p>以下是一个使用state的例子，用于更新最新时间</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Clock</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [date, setDate] = <span class="title function_">useState</span>(<span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">toLocaleTimeString</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">clickHandler</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setDate</span>(<span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">toLocaleTimeString</span>());</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;date&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;clickHandler&#125;</span>&gt;</span>刷新<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Clock</span>;</span><br></pre></td></tr></table></figure><p>其中的核心在于<code>useState</code>这个<strong>hook</strong>，它可以接受一个值，返回一个数组包含两个元素，一个始化的值一个set函数。这个初始化的值就是一个普通变量，直接修改这个初始化值的变量是不会对组件产生实质性的影响。要想修改而是使用这个set函数，它接受一个新的state值或回调，调用后会触发组件的重新渲染，从而使得页面刷新。</p><h3 id="State的问题"><a href="#State的问题" class="headerlink" title="State的问题"></a>State的问题</h3><p>state的set函数是异步的，这就引发了一个问题。如果我们快速的触发了两次set函数，有可能会导致state在未更新的情况下又被传入set函数中，这相当于我们白调了一次函数并且看起来它像是自带防抖，但有时候我们并不想这样。</p><p>对此我们可以可以传入一个回调函数，回调函数的参数中会被注入确保是最新的state值，回调函数返回的值将会作为最新state值。</p><h2 id="获取原生DOM"><a href="#获取原生DOM" class="headerlink" title="获取原生DOM"></a>获取原生DOM</h2><p>在React中虽然可以通过原生API获取DOM，但这显得不太优雅。React提供了<code>useRef</code>Hook来帮助我们获取DOM。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useRef &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Ref</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> divRef = <span class="title function_">useRef</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;divRef&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span> console.log(divRef.current)&#125;&gt;点我查看ref<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Ref</span>;</span><br></pre></td></tr></table></figure><p><code>useRef</code>实际返回的是一个普通的JS对象，所以上例中即使我们不使用钩子函数，仅仅创建一个形如<code>&#123;current:null&#125;</code>的对象也是可以的。只是我们自己创建的对象组件每次渲染时都会重新创建一个新的对象，而通过<code>useRef()</code>创建的对象可以确保组件每次的重渲染获取到的都是相同的对象。</p><p>另外需要注意的是尽量不要在React中直接操作DOM。</p>]]></content>
      
      
      <categories>
          
          <category> WEB前端 </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack学习笔记</title>
      <link href="/posts/6c4d4f8.html"/>
      <url>/posts/6c4d4f8.html</url>
      
        <content type="html"><![CDATA[<p>哈哈哈</p>]]></content>
      
      
      <categories>
          
          <category> WEB前端 </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>田地尺寸</title>
      <link href="/posts/ef96aa55.html"/>
      <url>/posts/ef96aa55.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试。" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="fd651383ae244df0ccc9f7752597f5a889666cbc39f4d527b33480b0a5b32bc5">e9acecd67e265fa249589e540d2e07210f67914e6aeac52812ffd07b11b90437b1942216bd1da13df912c1c379aed9649b0ee3f70172be586d238632c95c804bccc1a96b7a5df8ebe6390b0bbc1fbd10e2c28fd125f267d0271e00be1fb1acddb815f31d4c97717f7a2acb8ec1dc43592e561d750b3848753196f0cd5648c0647629f8e9347df32afff4f7109d0696dd6ad05bd6a21cda39f46d4b06735ef679f04d1f8dfe047ecc602aaec51d229f46c99bceb0e25c34347691462f762daf2e640715adad55bdc342c0e24d73bcf49318433e7b2c47d0007fc4bc9750e549b210b0d213cf4b66f9827f10ee8a3a69555f4a0d94a3d93fe49e743c45dbae075f3548f61ce431f8e12beb47a4bf7e4f4abf43effd1cc4b2a7742690a57a3340e7056b5c1a478e295de79410ac7720e34de2b6a7cc2250707ceda37315257fd04758d585828d23f02e6902d4f9b24a4b01e611d94c6bc57d639a3ca17624a0c385fc77ab5eae67f662f560e2f502ac7406d3a38abed094cca3b1ebc940de9e72cf9cb59d43b75338ea88961b5ef0e497f433f03aff3cc145ad34a239f4939ec8787c9354bc8115194d4346926826bb5c0f7ad2e517bdd4b7dc52ea30a1efc98624615adc2482186d0bd040bc4f032380513521d0e7c9b6644182c60a2f132f617f3eb09ee7f7f153264ebd4d48feaa1aef8e515614df725ef5b6250a0ab2d1e8e81af9050499f5a2c14a7d934981b7388bf269d6c22793cf922897849cdaa86dde1c353df2abc9d34b65f2a3485c4de59287b940fc920bc0270d9fe78cbe748fea3426c4c3c1932d7cd85dca31c62f1445e350fd9783d85d9fab0057fc12134a7a1011fcd40e86f1bd79bdcd3fd46c6d38071627f5bbe690ba9fac15f57d033706b9aa73e1e71cc037025ab1bdaf83032d2f6397c453ef35216f715e0646ac3af775a503843964051a5c3d82ce7a0d683101741f5219396e558a97bcffc37a8977a70a91613029ff0fcab2ee715be014ab4fa710ca9c308ca6be425e676d8a50c151ddac6bf78fcd19f25a3247a194b36f8a90a563d9a81dd0a8388c25d09d92a2059fb9fe1f27c84e5d7e68d0a50c82d6b614d76520965b62422e314afeecbcb4568d01d0cb4c8ae74b606661cd6b335ccb5f2d74a1720f9d0934bb84846121080a3a9a3137fb17849f6f0ee2382cf4700137f0e9312a2ec07fc987ebc2706ea956e3170b4ea606a6477de36d3aca27f44217a45a7de7e79227be47e6851e444b651c7334a1ab3c2216d819c7061294913ab24a34e5ecb3f57c85e943a40b2ab1a9d265999f04b5fd09a6a1888df45e82377ad53fbcd861f4cb61d5ced9b32e0dc7e6fc91548a9d153c7a83c4518448b93849d2cd82b546a29a29f279b0688876392b5d4df6c99c5b55c6a0530c7324703117aa8fb82c50675cc43bf8d14f0f32daebfbd84ad52a3231017321e0d45eaf04c1d4131ef634bc8deb3b3b240d20558cfe11004a324f9bdc8b05c05e8d7a53e8293654ccb487534394ecf112957abea59a60f60474392f59185d727ff80cd44daba0019e0c1c512dd15aff92ef7b0dbeaec694f31ed7dfd493fc6137a56bc010d51f1450d42596c841c4366b05e2856468811ba9ffc72098bc8b10bcbd4b32b5f43927c08c1e3a2d290e58f7262607c8ace2533928c324f277e5698a92b9bfea8529a1b2d7a49d1f1330daef572f7eddb37a67fd0e46f1fc319c36bf61a1f07cd006f6debe44cccc21554c932f378d7f5faf30cb43025626fde010fa60c5802cf5b75c0c87987dab8537be08efe493bd610882ebfc51a368687b0d12ffed7fcf34bd63f54cc4433eaa5b24a6a2d4a2b4f8d66bf914140ec83dfd931a72fa37523704afde0a8d580808c01a1790a035d3a8e4f1c72e72d6bb08b7e85b784168664fb539c95b51f96c440ae8ca426fe18df64234046b42546f4be4d6cbee14aaa2cb8e458ca4af03444027af87013dec3b019f26410cb3de7fa268da6b74ee86ded0083a9e57621ce706814d020430ccec4db4e9807f36384783b40ae9666c3efed24982dcc540de9faa5971f5cb4a66d2c7698ade5ab8eedef656393f98f08db3b3f2aa589d7ee2a0cf3c22f793e7fdd174e3abf7591fd6c8aacc0951f66ba65d42f01dc24c5c0995fe0024b3b66a355396b88085a42fac6d482eb7d501fe8700a0292cefe4cb348200d4763d1625336ddbc74d4bca05e171a14b2f9029c58a25f80f996fe24568680f619ea329aa868c88f71eed9de925a591513acc3cfe42a43003268ddf00835572aeb50e8530d9c5ed923c9be388b06ad292da031eb8543c5804981939dd0c55e426b06b22f8a5a657587acc995cdba87b96fcd655a97c9e8bdda7c581761b96a190a07daddc20</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码。</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 农业 </tag>
            
            <tag> 田地 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3新特性学习</title>
      <link href="/posts/ce9913b7.html"/>
      <url>/posts/ce9913b7.html</url>
      
        <content type="html"><![CDATA[<div class="note info flat"><p>前言：Vue3出来很长一段时间了，而我还在用Vue2，是不是<span class='p red'>OUT了</span>，于是赶紧来学习Vue3</p></div><h2 id="什么是Vue？"><a href="#什么是Vue？" class="headerlink" title="什么是Vue？"></a>什么是Vue？</h2><p>首页来复习一下什么是Vue，官方说Vue是一款用于构建用户界面的渐进式 JavaScript 框架。并提供了一套声明式的、组件化的编程模型。嗯有几个概念比较模糊，<strong>渐进式</strong>、<strong>声明式</strong>、<strong>组件化</strong>。</p><h3 id="渐进式？"><a href="#渐进式？" class="headerlink" title="渐进式？"></a>渐进式？</h3><p>简单来说就是可以全部是Vue也可以一部分是Vue。举个栗子，我们有一个老项目用JQ写的，现在我想给老项目增加页面，而这个页面我就可以用Vue写，不必替换掉JQ直接再引个Vue，它两之间是不干扰的，逐渐的就可以把JQ整个替换掉了。</p><h3 id="声明式？"><a href="#声明式？" class="headerlink" title="声明式？"></a>声明式？</h3><p>要了解声明式就要先了解命令式。啥是命令式，还是举个栗子，我们想要在页面中增加一个h1标题，这时就要做：1.获取父元素； 2.创建h1元素；3.往h1元素中注入内容；4.把h1标签塞到父元素中；这种列出过程来一步一步来就可以理解为命令式。而声明式就是让你不用关心过程，只用关心呈现结果。</p><h3 id="组件化？"><a href="#组件化？" class="headerlink" title="组件化？"></a>组件化？</h3><p>组件化也简单来说就是，把页面拆成一个一个模块，模块之间可以复用，当然整个页面也可以是一个组件。</p><h2 id="Vue2和Vue3组件创建方式对比"><a href="#Vue2和Vue3组件创建方式对比" class="headerlink" title="Vue2和Vue3组件创建方式对比"></a>Vue2和Vue3组件创建方式对比</h2><p>Vue2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  new Vue(&#123;</span><br><span class="line">    el: &#x27;#root&#x27;,</span><br><span class="line">    template: &#x27;&lt;h1&gt;Hello World!&lt;/h1&gt;&#x27;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>Vue3</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  Vue.createApp(&#123;</span><br><span class="line">    template: &#x27;&lt;h1&gt;Hello World!&lt;/h1&gt;&#x27;</span><br><span class="line">  &#125;).mount(&#x27;#app&#x27;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="使用Vite脚手架工具创建项目"><a href="#使用Vite脚手架工具创建项目" class="headerlink" title="使用Vite脚手架工具创建项目"></a>使用Vite脚手架工具创建项目</h3><p>首先<a href="https://cn.vitejs.dev/">Vite</a> 是一个轻量级的、速度极快的构建工具，对标的是webpack</p><p>Vue3推荐使用Vite脚手架工具来创建项目，而不是继续使用Vue CLI而且Vue CLI已经不再维护</p><h4 id="人肉一个脚手架"><a href="#人肉一个脚手架" class="headerlink" title="人肉一个脚手架"></a>人肉一个脚手架</h4><p>使用pnpm来替代npm，pnpm的性能比npm要好</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i pnpm -g</span><br></pre></td></tr></table></figure><p>创建一个文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir demo</span><br></pre></td></tr></table></figure><p>初始化</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm init</span><br></pre></td></tr></table></figure><p>安装vite</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm add vite -D</span><br></pre></td></tr></table></figure><p>安装Vue</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm add vue -D</span><br></pre></td></tr></table></figure><p>在<u>根目录/src</u>下新建main.js，没有src目录就新建</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import &#123; createApp &#125; from &#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue/dist/vue.esm-bundler.js&#x27;</span> <span class="comment">// 默认的 vue 不支持 template 写法，故而使用vue/dist/vue.esm-bundler.js</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">createApp</span>(&#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;&lt;h1&gt;&#123;&#123;message&#125;&#125;&lt;/h1&gt;&#x27;</span>, <span class="comment">// 据说使用 template 性能不好，template 会转成函数再执行所以性能不好</span></span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).<span class="title function_">mount</span>(<span class="string">&#x27;#root&#x27;</span>)</span><br></pre></td></tr></table></figure><p>在根目录下新建index.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./src/main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后在package.json的scripts中添加</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;dev&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vite --open&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vite build&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;preview&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vite preview&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>运行命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm dev</span><br></pre></td></tr></table></figure><p>即可看见效果</p><p><img src="https://cdn.staticaly.com/gh/Elpis1999/markdown-picbed@main/img/image-20230520172757664.png" alt="image-20230520172757664"></p><p>接下来我们将组件写法改为单文件形式，并创建一个按钮组件My-Button</p><p>在<u>src/components</u>目录下创建My-Button.vue文件，没有components目录就新建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      count: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;button @click=&quot;count++&quot;&gt;点我+1&lt;/button&gt;</span><br><span class="line">    - &#123;&#123; count &#125;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>在<u>src</u>目录下创建App.vue文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">import MyButton from &#x27;./components/My-Button.vue&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    MyButton</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        message: &#x27;Hello World!&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;&#123;&#123;message&#125;&#125;&lt;/h1&gt;</span><br><span class="line">    &lt;My-Button&gt;&lt;/My-Button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>改造main.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createApp &#125; from &#x27;vue&#x27;</span><br><span class="line">import App from &#x27;./App.vue&#x27;</span><br><span class="line"></span><br><span class="line">createApp(App).mount(&#x27;#root&#x27;)</span><br></pre></td></tr></table></figure><p>这时并不能ok，且还会报错，那是因为浏览器并不认识.vue文件，还需要使用插件将.vue转成三剑客</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm i @vitejs/plugin-vue -D</span><br></pre></td></tr></table></figure><p>在项目根目录下新建vite.config.js文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> vue <span class="keyword">from</span> <span class="string">&#x27;@vitejs/plugin-vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="title function_">vue</span>()]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此我们的人肉脚手架就可以正常工作了</p><p><img src="https://cdn.staticaly.com/gh/Elpis1999/markdown-picbed@main/img/image-20230520201351994.png" alt="image-20230520201351994"></p><h4 id="自动创建脚手架"><a href="#自动创建脚手架" class="headerlink" title="自动创建脚手架"></a>自动创建脚手架</h4><p>很简单一个命令完事</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm create vue</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init vue@latest</span><br></pre></td></tr></table></figure><h2 id="组合式API"><a href="#组合式API" class="headerlink" title="组合式API"></a>组合式API</h2><p>Vue2默认所使用的是选项式API，Vue3则是组合式</p><h3 id="选项式"><a href="#选项式" class="headerlink" title="选项式"></a>选项式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        message: &#x27;Hello World!&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是对象写法，需要遵循对象的语法规范，并且看起来不太简洁，使用箭头函数也要小心，使用属性方法还要加<code>this</code>关键字</p><h3 id="组合式"><a href="#组合式" class="headerlink" title="组合式"></a>组合式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const message = &#x27;Hello World!&#x27;</span><br><span class="line">    </span><br><span class="line">    return &#123;</span><br><span class="line">      message</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>setup</code>是一个钩子，它在vue实例创建时会自动执行。我们所有的代码就可以写在<code>setup</code>里，并且他是一个函数，不用受到对象写法的约束，可以按照个人习惯编写代码。<code>return</code>暴露给外界使用，需要注意的是暴露的对象并不是响应式的，我们还需要使用Vue3提供的API使对象变为响应式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; ref &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const count = ref(0)</span><br><span class="line"></span><br><span class="line">    const add = () =&gt; &#123;</span><br><span class="line">      count.value += 1</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      count,</span><br><span class="line">      add</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h1&gt;&#123;&#123; count &#125;&#125;&lt;/h1&gt;</span><br><span class="line">  &lt;button @click=&quot;add&quot;&gt;点我+1&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>嗯上面的代码看起来还是繁琐的很，不用担心vue给我们提供了<code>setup</code>语法糖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">const count = ref(0)</span><br><span class="line"></span><br><span class="line">const add = () =&gt; (count.value += 1)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h1&gt;&#123;&#123; count &#125;&#125;&lt;/h1&gt;</span><br><span class="line">  &lt;button @click=&quot;add&quot;&gt;点我+1&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>这样一来是不是看起来舒服多了</p><h3 id="ref和reactive"><a href="#ref和reactive" class="headerlink" title="ref和reactive"></a>ref和reactive</h3><p>ref和reactive都是用于在setup中将数据转换为响应式的（代理对象），但它们有些不同</p><p>reactive是用于转换复杂数据类型如：对象、数组等，而基本数据类型则不行如：数字、字符串等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; reactive &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">const arr = reactive([&#x27;苹果&#x27;, &#x27;梨子&#x27;, &#x27;香蕉&#x27;])</span><br><span class="line">const count = reactive(0)</span><br><span class="line"></span><br><span class="line">const change = () =&gt; &#123;</span><br><span class="line">  console.log(arr) // Proxy(Array) &#123;0: &#x27;苹果&#x27;, 1: &#x27;梨子&#x27;, 2: &#x27;香蕉&#x27;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const add = () =&gt; &#123;</span><br><span class="line">  count++</span><br><span class="line">  console.log(count) // 0 0 0 0...</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h1 @click=&quot;add&quot;&gt;&#123;&#123;count&#125;&#125;&lt;/h1&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li v-for=&quot;(item ,index) in arr&quot; :key=&quot;index&quot; @click=&quot;change&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>可以看到无论点击h1多少此渲染的还是0，count不是响应式的只是单纯的数字0</p><p>ref则是既可以转换复杂数据类型也可以转换基本数据类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">const arr = ref([&#x27;苹果&#x27;, &#x27;梨子&#x27;, &#x27;香蕉&#x27;])</span><br><span class="line">const count = ref(0)</span><br><span class="line"></span><br><span class="line">const change = () =&gt; &#123;</span><br><span class="line">  console.log(arr) // RefImpl &#123;__v_isShallow: false, dep: Set(1), __v_isRef: true, _rawValue: Array(3), _value: Proxy(Array)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const add = () =&gt; &#123;</span><br><span class="line">  count.value++</span><br><span class="line">  console.log(count) // RefImpl &#123;__v_isShallow: false, dep: Set(1), __v_isRef: true, _rawValue: 1, _value: 1&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h1 @click=&quot;add&quot;&gt;&#123;&#123;count&#125;&#125;&lt;/h1&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li v-for=&quot;(item ,index) in arr&quot; :key=&quot;index&quot; @click=&quot;change(index)&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>可以看到怎么打印的结果和源数据怎么不一样呢，那是因为ref会将源数据再包装一层，是通过<code>count.value</code>改的值</p><h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p>在组合式中使用计算属性，使用<code>computed</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const message = computed(() =&gt; &#x27;xixi&#x27;)</span><br></pre></td></tr></table></figure><h2 id="模板与样式"><a href="#模板与样式" class="headerlink" title="模板与样式"></a>模板与样式</h2><p>在vue2中一个组件只能有一个根标签，而在vue3中一个组件支持可以拥有多个根标签，官方将其称为片段。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;&lt;/div&gt;</span><br><span class="line">  &lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p><code>scoped</code>可以隔离样式，其原理是给标签上加一个随机生成的自定义属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;!-- 在网页中实际是 &lt;div class=&quot;box&quot; data-v-xxxxxx&gt;&lt;/div&gt; --&gt;</span><br><span class="line">  &lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>这样各个组件之间自定义属性就会不一样，实际上给样式的时候vue会自动帮我们把这个自定义属性加上，从而达到选择器不同的效果，最后也就实现了样式隔离。</p><p>需要注意的是在vue3中如果一个组件中只有一个根标签，那么vue3会自动给这个根标签加上自定义属性，这也可能会导致样式“串味”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;!-- 在网页中实际是 &lt;div class=&quot;box&quot; data-v-114514&gt;&lt;/div&gt; --&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">// 子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p&gt;&lt;/p&gt; &lt;!-- 在网页中实际是 &lt;p data-v-114514&gt;&lt;/p&gt; --&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>而一个组件中有多个根标签，则不会加上自定义属性</p><h3 id="deep"><a href="#deep" class="headerlink" title="deep"></a>deep</h3><p>有些时候我们就是想在父组件中改变子组件的样式，这时我们可以使用deep选择器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;box&quot;&gt;</span><br><span class="line">    &lt;SubComponent&gt;&lt;/SubComponent&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">  .box :deep(p) &#123;</span><br><span class="line">      color: red;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">// 子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p&gt;&lt;/p&gt;</span><br><span class="line">  &lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="global"><a href="#global" class="headerlink" title="global"></a>global</h3><p>当我们想在组件中即使用<code>scoped</code>样式又使用一些全局样式该怎么做呢</p><p>可以使用多个style标签</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p&gt;&lt;/p&gt;</span><br><span class="line">  &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">  .box &#123;</span><br><span class="line">    background-color: cyan;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">  p &#123;</span><br><span class="line">    font-size: 18px;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>但是这样又使得文件臃肿和结构不清晰，其实还可以使用<code>:global</code>选择器，解决这个问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p&gt;&lt;/p&gt;</span><br><span class="line">  &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">  .box &#123;</span><br><span class="line">    background-color: cyan;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  :global(p) &#123;</span><br><span class="line">    font-size: 18px;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="module"><a href="#module" class="headerlink" title="module"></a>module</h3><p>CSS模块化<code>module</code>和<code>scoped</code>都能够实现样式的隔离</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div :class=&quot;$style.box&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;box&gt;&lt;/box&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style module&gt;</span><br><span class="line">.box &#123;</span><br><span class="line">  background-color: orangered;</span><br><span class="line">  width: 200px;</span><br><span class="line">  height: 200px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">// 子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style module&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>可以看到只有父组件的box显示出来了</p><p><img src="https://cdn.staticaly.com/gh/Elpis1999/markdown-picbed@main/img/image-20230522134530067.png" alt="image-20230522134530067"></p><p>CSS模块化<code>module</code>的原理是将box实际转换为<strong>_box_1s4h5_2</strong>，这是一个<strong>hash</strong>值也就是说这是一个唯一标识符，这也实现了每个组件之间类名不重复的效果</p><p>使用时需要向上方例子一样使用<code>:class=&quot;$style.类名&quot;</code></p><p>当然也可以给css模块起别名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div :class=&quot;classes.box&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;box&gt;&lt;/box&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style module=&quot;classes&quot;&gt;</span><br><span class="line">.box &#123;</span><br><span class="line">  background-color: orangered;</span><br><span class="line">  width: 200px;</span><br><span class="line">  height: 200px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="在style标签中使用指令"><a href="#在style标签中使用指令" class="headerlink" title="在style标签中使用指令"></a>在style标签中使用指令</h3><p>另外在style标签中也也可使用vue的一些指令</p><p>v-bind</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">import Box from &#x27;./components/Box.vue&#x27;</span><br><span class="line"></span><br><span class="line">const orangered = &#x27;orangered&#x27;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div :class=&quot;classes.box&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style module=&quot;classes&quot;&gt;</span><br><span class="line">.box &#123;</span><br><span class="line">  background-color: v-bind(orangered);</span><br><span class="line">  width: 200px;</span><br><span class="line">  height: 200px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><h3 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h3><p>通过Vue的 <code>&lt;component&gt;</code> 元素和特殊的 <code>is</code> 属性来实现组件之间的切换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; ref &#125; from &#x27;vue&#x27;</span><br><span class="line">import A from &#x27;./A.vue&#x27;</span><br><span class="line">import B from &#x27;./B.vue&#x27;</span><br><span class="line"></span><br><span class="line">const current = ref(true)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;component :is=&quot;current ? A : B&quot;&gt;&lt;/component&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>效果等价与<code>v-if</code></p><h3 id="透传-Attributes"><a href="#透传-Attributes" class="headerlink" title="透传 Attributes"></a>透传 Attributes</h3><p>透传指的是传递给一个组件，且该组件只有一个根元素，且没有被该组件声明为props和emits的属性和事件，将会直接坐落在该根元素身上。最常见的例子就是 <code>class</code>、<code>style</code> 和 <code>id</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;A</span><br><span class="line">    class=&quot;box1&quot;</span><br><span class="line">    style=&quot;width: 100px; height: 100px;&quot;</span><br><span class="line">  &gt;&lt;/A&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">// 子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div</span><br><span class="line">    class=&quot;box2&quot;</span><br><span class="line">    style=&quot;background-color: aquamarine&quot;</span><br><span class="line">       &gt;&lt;/div&gt; &lt;!-- 实际渲染 &lt;div class=&quot;box2 box1&quot; style=&quot;width: 100px; height: 100px; background-color: aquamarine;&quot;&gt;&lt;/div&gt; --&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>当然事件也一样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">import A from &#x27;./components/A.vue&#x27;</span><br><span class="line"></span><br><span class="line">const clickHandler = () =&gt; &#123;</span><br><span class="line">  alert(&#x27;A&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;A</span><br><span class="line">    class=&quot;box1&quot;</span><br><span class="line">    style=&quot;width: 100px; height: 100px&quot;</span><br><span class="line">    @click=&quot;clickHandler&quot;</span><br><span class="line">  &gt;&lt;/A&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">// 子组件</span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">const clickHandler = () =&gt; &#123;</span><br><span class="line">  alert(&#x27;B&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div</span><br><span class="line">    class=&quot;box2&quot;</span><br><span class="line">    style=&quot;background-color: aquamarine&quot;</span><br><span class="line">    @click=&quot;clickHandler&quot;</span><br><span class="line">  &gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>结果弹了两个alert，先是A再是B</p><h4 id="禁用透传"><a href="#禁用透传" class="headerlink" title="禁用透传"></a>禁用透传</h4><p>需要额外一个script标签来声明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">// 使用普通的 &lt;script&gt; 来声明选项</span><br><span class="line">export default &#123;</span><br><span class="line">  inheritAttrs: false</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">// ...setup 部分逻辑</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>或者使用<code>defineOptions</code>宏，vue3.3+支持</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">defineOptions(&#123;</span><br><span class="line">  inheritAttrs: false</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="多根元素的透传"><a href="#多根元素的透传" class="headerlink" title="多根元素的透传"></a>多根元素的透传</h4><p>区别于单根组件，多根组件没有自动透传的行为。如果 <code>$attrs</code> 没有被显式绑定，将会抛出一个运行时警告。</p><p>我们可以给其中一个根元素绑定<code>$attrs</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div</span><br><span class="line">    class=&quot;box2&quot;</span><br><span class="line">    style=&quot;background-color: aquamarine&quot;</span><br><span class="line">    @click=&quot;clickHandler&quot;</span><br><span class="line">    :=&quot;$attrs&quot;</span><br><span class="line">  &gt;&lt;/div&gt;</span><br><span class="line">  &lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p><code>:=&quot;$attrs&quot;</code>等价于<code>v-bind=&quot;$attrs&quot;</code></p><h4 id="在JS中访问透传属性"><a href="#在JS中访问透传属性" class="headerlink" title="在JS中访问透传属性"></a>在JS中访问透传属性</h4><p>可以使用<code>useAttrs</code>方法来访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; useAttrs &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">const attrs = useAttrs()</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="Vue2与Vue3的-attrs对比"><a href="#Vue2与Vue3的-attrs对比" class="headerlink" title="Vue2与Vue3的$attrs对比"></a>Vue2与Vue3的$attrs对比</h3><p>在Vue2中$attrs并不包含class和style以及事件（$listeners）。</p><p>在Vue3中$attrs包含class和style，因为$listeners以及废弃，所以也包含事件（$listeners）。</p><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p>在Vue3中提供了新的方法以实现组件之间的跨层传递数据，它就是依赖注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 爷爷组件</span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; ref, provide &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">const count = ref(0)</span><br><span class="line"></span><br><span class="line">provide(&#x27;count&#x27;, count)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">// 父组件</span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">// ...其他逻辑</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">// 子组件</span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; inject, type Ref &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">const count = inject&lt;Ref&lt;number&gt;&gt;(&#x27;count&#x27;)</span><br><span class="line"></span><br><span class="line">count!.value = 1</span><br><span class="line">console.log(count) // 1</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><code>Provide</code> 负责提供，<code>inject</code>负责注入。另外<code>inject</code>还可以指定默认值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; inject, type Ref, ref &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">const count = inject&lt;Ref&lt;number&gt;&gt;(&#x27;count&#x27;, ref(0))</span><br><span class="line"></span><br><span class="line">count.value = 1</span><br><span class="line">console.log(count) // 1</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>当注入的<code>count</code>不存在时则启用默认值</p><h2 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h2><h3 id="简单状态管理"><a href="#简单状态管理" class="headerlink" title="简单状态管理"></a>简单状态管理</h3><p>在Vue3中可以直接使用响应式API来做到简单的状态管理，不必借助其他插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">// App.vue</span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">import Root from &#x27;./components/Root.vue&#x27;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p&gt;APP&lt;/p&gt;</span><br><span class="line">  &lt;Root&gt;&lt;/Root&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">// Root.vue</span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">import A from &#x27;./A.vue&#x27;</span><br><span class="line">import B from &#x27;./B.vue&#x27;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h1&gt;根组件&lt;/h1&gt;</span><br><span class="line">  &lt;A&gt;&lt;/A&gt;</span><br><span class="line">  &lt;B&gt;&lt;/B&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">// A.vue</span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123;countStore&#125; from &#x27;@/store/countStore&#x27;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p&gt;A -&gt; count:&#123;&#123;countStore.count&#125;&#125; &lt;button @click=&quot;countStore.add&quot;&gt;+1&lt;/button&gt;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">// B.vue</span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">import C from &#x27;./C.vue&#x27;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p&gt;B&lt;/p&gt;</span><br><span class="line">  &lt;C&gt;&lt;/C&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">// C.vue</span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123;countStore&#125; from &#x27;@/store/countStore&#x27;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p&gt;C -&gt; count:&#123;&#123;countStore.count&#125;&#125; &lt;button @click=&quot;countStore.add&quot;&gt;+1&lt;/button&gt;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>可以看到我们在两个毫不相干的组件中使用了<code>count</code>属性和<code>add</code>方法</p><p>在<strong>src</strong>目录下新建<u>store/countStore.ts</u></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> countStore = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="title function_">add</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span>++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Pinia"><a href="#Pinia" class="headerlink" title="Pinia"></a>Pinia</h3><p>虽然说上述的简单状态管理在简单的场景中已经足够了，但是在大规模的生产应用中还有很多其他事项需要考虑如：团队协作约定、Vue DevTools 集成、模块热更新、服务端渲染支持。</p><p>Pinia就是一个实现了上述需求的状态管理库，它与vuex是相似的。只是在vue2中推荐使用的是vuex，vue3中则是Pinia。</p><h4 id="使用Pinia"><a href="#使用Pinia" class="headerlink" title="使用Pinia"></a>使用Pinia</h4><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pnpm add pinia</span><br><span class="line"><span class="comment"># 或者使用 npm</span></span><br><span class="line">npm install pinia</span><br></pre></td></tr></table></figure><p>将Pinia作为插件使用</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; createPinia &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pinia = <span class="title function_">createPinia</span>()</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(pinia)</span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><p>改造上面的countStore.ts文件</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineStore &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useCountStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;counter&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">state</span>: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;),</span><br><span class="line"></span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="title function_">add</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">count</span>++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>为了规范化，在变量名前面加上<code>use</code>代表是一个钩子函数</p><p>需要注意的是<code>defineStore</code>返回的是一个函数，应该这么用</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A组件</span></span><br><span class="line">&lt;script setup lang=<span class="string">&quot;ts&quot;</span>&gt;</span><br><span class="line"><span class="keyword">import</span> &#123;useCountStore&#125; <span class="keyword">from</span> <span class="string">&#x27;@/store/countStore&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> countStore = <span class="title function_">useCountStore</span>()</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>A -&gt; count:&#123;&#123;countStore.count&#125;&#125; <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;countStore.add&quot;</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>另外<code>defineStore</code>的写法也可以是组合式</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useCountStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;counter&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params"></span>) =&gt; count.<span class="property">value</span>++</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    count,</span><br><span class="line">    add</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>useCountStore</code>函数返回的是一个<code>reactive</code>对象，所以我们直接解构出来的属性不是响应式的。Pinia中提供了一个<code>storeToRefs</code>可以帮助我们将解构出来的值转为响应式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; useCountStore &#125; from &#x27;@/store/countStore&#x27;</span><br><span class="line">import &#123; storeToRefs &#125; from &#x27;pinia&#x27;</span><br><span class="line"></span><br><span class="line">const countStore = useCountStore()</span><br><span class="line"></span><br><span class="line">const &#123; count &#125; = storeToRefs(countStore)</span><br><span class="line">const &#123; add &#125; = countStore</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p&gt;</span><br><span class="line">    A -&gt; count:&#123;&#123; count &#125;&#125;</span><br><span class="line">    &lt;button @click=&quot;add&quot;&gt;+1&lt;/button&gt;</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>注意方法（actions）不是响应式的直接解构即可。</p><h4 id="修改state"><a href="#修改state" class="headerlink" title="修改state"></a>修改state</h4><p>我们在vuex中修改state是投过Mutation来修改的，在pinia中我们则可以通过多种方式来修改state</p><p>直接修改</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="title function_">useStore</span>()</span><br><span class="line"></span><br><span class="line">store.<span class="property">count</span>++</span><br></pre></td></tr></table></figure><p>重置state</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="title function_">useStore</span>()</span><br><span class="line"></span><br><span class="line">store.$reset()</span><br></pre></td></tr></table></figure><p>这将state重置为初始值</p><p>$patch修改</p><p>$patch有两种修改方式，并且它可以同时修改多个值</p><p>对象式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">store.$patch(&#123;</span><br><span class="line">  <span class="attr">count</span>: store.<span class="property">count</span> + <span class="number">1</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">120</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;DIO&#x27;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>函数式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">store.$patch(<span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">  state.<span class="property">items</span>.<span class="title function_">push</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;shoes&#x27;</span>, <span class="attr">quantity</span>: <span class="number">1</span> &#125;)</span><br><span class="line">  state.<span class="property">hasChanged</span> = <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>函数式可以帮助我们做更深层次的修改</p><p>需要注意的是不能完全的替换state，因为那样会破坏其响应性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这实际上并没有替换`$state`</span></span><br><span class="line">store.<span class="property">$state</span> = &#123; <span class="attr">count</span>: <span class="number">24</span> &#125;</span><br><span class="line"><span class="comment">// 在它内部调用 `$patch()`：</span></span><br><span class="line">store.$patch(&#123; <span class="attr">count</span>: <span class="number">24</span> &#125;)</span><br></pre></td></tr></table></figure><h4 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h4><p>pinia中的订阅就有些想vue中的watch，它可以帮助我们监视state和action，当state发生改变或action发生调用就会触发它。</p>]]></content>
      
      
      <categories>
          
          <category> WEB前端 </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript学习笔记</title>
      <link href="/posts/4a9ed04d.html"/>
      <url>/posts/4a9ed04d.html</url>
      
        <content type="html"><![CDATA[<div class="note info flat"><p>参考：<a href="https://juejin.cn/post/7018805943710253086?share_token=c4029c41-9cc7-4e39-9e2d-c57b6617d2d8#heading-121">typescript史上最强学习入门文章</a></p></div><h2 id="TypeScript介绍"><a href="#TypeScript介绍" class="headerlink" title="TypeScript介绍"></a>TypeScript介绍</h2><h3 id="什么是TypeScript？"><a href="#什么是TypeScript？" class="headerlink" title="什么是TypeScript？"></a>什么是TypeScript？</h3><blockquote><p>TypeScript简称TS</p><p>TS是微软开源的一款以JS为基础构建的编程语言</p><p>TS是JS的超集，JS有的TS都有，并且TS拓展了JS没有的内容</p></blockquote><h3 id="为什么需要TypeScript？"><a href="#为什么需要TypeScript？" class="headerlink" title="为什么需要TypeScript？"></a>为什么需要TypeScript？</h3><blockquote><p>简单来说就是因为JavaScript是弱类型, 很多错误只有在运行时才会被发现<br>而TypeScript提供了一套静态检测机制, 可以帮助我们在编译时就发现错误<br>变相的降低了多人协作开发和后续维护的成本</p></blockquote><h3 id="TypeScript特点"><a href="#TypeScript特点" class="headerlink" title="TypeScript特点"></a>TypeScript特点</h3><blockquote><p>支持ES最新特性</p><p>支持类型检查</p><p>添加了ES不具备的新特性。诸如C++，Java，Go等后端语言中的特性 (枚举、泛型、类型转换、命名空间、声明文件、类、接口等)</p><p>丰富的配置选项（可配置将TS转成ES5、ES6等）</p><p>强大的编辑器支持</p><p>TS可以在任何支持JS的平台中使用，但TS不能被JS解析器直接执行，所以需要将TS编译成JS执行</p></blockquote><h2 id="TypeScript环境搭建"><a href="#TypeScript环境搭建" class="headerlink" title="TypeScript环境搭建"></a>TypeScript环境搭建</h2><h3 id="全局安装TypeScript"><a href="#全局安装TypeScript" class="headerlink" title="全局安装TypeScript"></a>全局安装TypeScript</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g typescript</span><br></pre></td></tr></table></figure><h3 id="创建tsconfig-json文件"><a href="#创建tsconfig-json文件" class="headerlink" title="创建tsconfig.json文件"></a>创建tsconfig.json文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc --init</span><br></pre></td></tr></table></figure><h3 id="全局安装ts-node"><a href="#全局安装ts-node" class="headerlink" title="全局安装ts-node"></a>全局安装ts-node</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g ts-node</span><br></pre></td></tr></table></figure><p>通常情况下需要将<code>xxx.ts</code>使用<code>tsc xxx.ts</code>编译为<code>xxx.js</code>才能交给<code>node</code>执行，使用<code>ts-node</code>命令可直接执行<code>.ts</code>文件，<code>ts-node</code>命令内部自动将<code>TS=&gt;JS</code>，再<code>node</code>执行</p><p><img src="https://cdn.staticaly.com/gh/Elpis1999/markdown-picbed@main/img/image-20230518191451935.png" alt="image-20230518191451935"></p><p><img src="https://cdn.staticaly.com/gh/Elpis1999/markdown-picbed@main/img/image-20230518191556199.png" alt="image-20230518191556199"></p><h3 id="playground"><a href="#playground" class="headerlink" title="playground"></a>playground</h3><p><a href="https://www.typescriptlang.org/zh/play?#code/PTAEiJrQ5+MU3NAYlUAqBPADgUwMoGMBOBLFAF1EBR7QYb9AudUBh-gKBFEE34wejNAAOUCo5QTb9ADeUAXjQbPlAaP6BMxSqAwJUDVcoBiVQGbagAzlEqTLgLFAIW6BFf0CbXoCAGGnTCAKg0D3yoFO5E4CDNQNBygSDlAs56BO00Dw+oH95QBSugYO1AWP-79oUAFpQdkBYOUAseUAWD0B5dUBvuUBVeUAcOUB-SNU5BXRsfCJQVUAGdXtdegCgtkBleUAYrLSlTOJAW+jAVZtANz1AODlAaojALrkJXPzfIvZXQDi5QGlbQFXo4MAYFUqMlVABQEXowHxzQHylQF+A1UBMm0BG710aLAB7ADsAZ2IAQ32AUQAPE4BbFAAbNAA1E-wTgCNH0ABeUAAiAASaHu912oAA6rscPcACZ-HYHQ67R4AOlBAHMABRnK63B7PV54D6PACUenopkAnQ6Ab8VAFBy9lUoEAOASALk9ANHygFwCUCANCNmYAG00A36kcqgmQBhcoBjyMAL2aALE1AM6K-RqgAAo1SAQ-lAPYG2nh9G5gFAAwAESoATNIYgGy5QAXNoApxIagBQ5QAA+oBpzTcVEALqZscgUVSANDlADKugF+EwB6Ov0uLo-EA">Playground</a>官方提供的一个线上环境</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="JS的八种内置类型"><a href="#JS的八种内置类型" class="headerlink" title="JS的八种内置类型"></a>JS的八种内置类型</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">str</span>: <span class="built_in">string</span> = <span class="string">&#x27;Hello World!&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">num</span>: <span class="built_in">number</span> = <span class="number">233</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">bool</span>: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">u</span>: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">n</span>: <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>: <span class="built_in">object</span> = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">big</span>: <span class="built_in">bigint</span> = <span class="number">100n</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">sym</span>: <span class="built_in">symbol</span> = <span class="title class_">Symbol</span>(<span class="string">&quot;me&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>bigint</code>是<code>ES2020</code>引入的一个新的原始数据类型，表示大整数（整数范围超过2<sup>53</sup>-1的数值）<br><code>symbol</code>是<code>ES6</code>引入的一个新的原始数据类型，表示独一无二的值，可以看作是一个唯一的、不可变的标记，用于对象中属性的标识符。</p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><h4 id="null和undefined"><a href="#null和undefined" class="headerlink" title="null和undefined"></a>null和undefined</h4><p>默认情况下<code>null</code>和<code>undefined</code>是所有类型的子类型，也就是说可以把<code>null</code>和<code>undefined</code>赋值给其他类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">num</span>: <span class="built_in">number</span> = <span class="number">2333</span>;</span><br><span class="line">num = <span class="literal">null</span>;</span><br><span class="line">num = <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure><p>如果在<code>tsconfig.json</code>中指定了<code>strictNullChecks: true</code>或者<code>strict: true</code>，那么<code>null</code>和<code>undefined</code>只能赋值给<code>void</code>和它们的各自类型</p><h4 id="number和bigint"><a href="#number和bigint" class="headerlink" title="number和bigint"></a>number和bigint</h4><p><code>number</code>和<code>bigint</code>都表示数字，但是二者的类型不兼容</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">big</span>: <span class="built_in">bigint</span> = <span class="number">100n</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">num</span>: <span class="built_in">number</span> = <span class="number">10</span>;</span><br><span class="line">big = num; <span class="comment">// 不能将类型“number”分配给类型“bigint”。ts(2322)</span></span><br></pre></td></tr></table></figure><p>抛出一个类型不兼容的 ts(2322) 错误</p><h3 id="Array数组"><a href="#Array数组" class="headerlink" title="Array数组"></a>Array数组</h3><p>数组类型的定义方式有两种：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>: <span class="built_in">string</span>[] = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr2</span>: <span class="title class_">Array</span>&lt;<span class="built_in">string</span>&gt; = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>];</span><br></pre></td></tr></table></figure><p>定义联合类型的数组：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>: (<span class="built_in">number</span> | <span class="built_in">string</span>)[] = [<span class="number">1</span>, <span class="string">&#x27;2&#x27;</span>, <span class="number">3</span>, <span class="string">&#x27;4&#x27;</span>];</span><br></pre></td></tr></table></figure><p>定义指定对象成员的数组：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Arrobj</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>: <span class="title class_">Arrobj</span>[] = [&#123; <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;]</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">sum</span>: <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> = <span class="keyword">function</span> (<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接口定义函数类型"><a href="#接口定义函数类型" class="headerlink" title="接口定义函数类型"></a>接口定义函数类型</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">SumFunc</span> &#123;</span><br><span class="line">    (<span class="attr">x</span>: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span>): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">sum</span>: <span class="title class_">SumFunc</span> = <span class="keyword">function</span> (<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用函数表达式接口定义函数的方式时，对等号左侧进行类型限制，可以保证以后对函数名赋值时保证参数个数、参数类型、返回值类型不变</p><h4 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName?: <span class="built_in">string</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (lastName) &#123;</span><br><span class="line">        <span class="keyword">return</span> firstName + lastName;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> firstName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">buildName</span>(<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Cat&#x27;</span>); <span class="comment">// TomCat</span></span><br><span class="line"><span class="title function_">buildName</span>(<span class="string">&#x27;Tom&#x27;</span>); <span class="comment">// Tom</span></span><br></pre></td></tr></table></figure><p>注意：可选参数后面不允许再出现必需参数</p><h4 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName: <span class="built_in">string</span> = <span class="string">&#x27;Cat&#x27;</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> firstName + lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">buildName</span>(<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Cat&#x27;</span>); <span class="comment">// TomCat</span></span><br><span class="line"><span class="title function_">buildName</span>(<span class="string">&#x27;Tom&#x27;</span>); <span class="comment">// TomCat</span></span><br></pre></td></tr></table></figure><h4 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">...numbers: <span class="built_in">number</span>[]</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> numbers.<span class="title function_">reduce</span>(<span class="function">(<span class="params">sum, current</span>) =&gt;</span> sum += current, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</span><br></pre></td></tr></table></figure><p>注意：剩余参数只能出现在函数参数列表的末尾位置</p><h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><p><code>JavaScript</code>是一门动态语言，我们通常会使用不同类型的参数来调用同一个函数，该函数会根据不同的参数而返回不同的类型的调用结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 3</span></span><br><span class="line"><span class="title function_">add</span>(<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>); <span class="comment">// &#x27;12&#x27;</span></span><br></pre></td></tr></table></figure><p>在默认情况下以上的代码可以直接在<code>TypeScript</code>中使用，但是当<code>TypeScript</code>编译器开启<code>noImplicitAny</code>或<code>strict</code>配置时，以上代码会提示以下错误信息：<code>Parameter &#39;x&#39; implicitly has an &#39;any&#39; type.</code> <code>Parameter &#39;y&#39; implicitly has an &#39;any&#39; type.</code></p><p>x和y具有隐式的<code>any</code>类型，为了解决这个问题，我们可以为参数设置一个类型。因为我们希望 <code>add</code> 函数同时支持 <code>string</code>和<code>number</code>类型，所以可以使用<code>type</code>关键字定义一个<code>string</code>和<code>number</code>的联合类型，同时我们为该联合类型取个别名：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Combinable</span> = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br></pre></td></tr></table></figure><p>在定义完Combinable联合类型后，我们来更新一下 <code>add</code> 函数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a: Combinable, b: Combinable</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="string">&#x27;string&#x27;</span> || <span class="keyword">typeof</span> b === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.<span class="title function_">toString</span>() + b.<span class="title function_">toString</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="title function_">add</span>(<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>);</span><br></pre></td></tr></table></figure><p>但是当 <code>add</code> 中传入的参数中包含有空格，而我想去掉空格：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> result = <span class="title function_">add</span>(<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27; Cat&#x27;</span>);</span><br><span class="line">result.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>);</span><br></pre></td></tr></table></figure><p><code>add</code> 如果返回的是<code>number</code>，这时就会发生错误<code>Property &#39;split&#39; does not exist on type &#39;number&#39;.</code>，因为<code>split</code>方法在<code>string</code>类型对象上才有而<code>number</code>类型对象上没有。问题又来了，那如何解决呢？这时我们就可以利用 <code>TypeScript</code> 提供的函数重载特性</p><blockquote><p><span class='p cyan'>函数重载</span>可以让函数接受不同数量或类型的参数，以便以不同的方式对它们进行操作。</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Types</span> = <span class="built_in">number</span> | <span class="built_in">string</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a:<span class="built_in">number</span>,b:<span class="built_in">number</span></span>):<span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a: <span class="built_in">string</span>, b: <span class="built_in">string</span></span>): <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a: <span class="built_in">string</span>, b: <span class="built_in">number</span></span>): <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">string</span></span>): <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a:Types, b:Types</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="string">&#x27;string&#x27;</span> || <span class="keyword">typeof</span> b === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="title function_">toString</span>() + b.<span class="title function_">toString</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> result = <span class="title function_">add</span>(<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27; Cat&#x27;</span>);</span><br><span class="line">result.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这时就可以根据参数的区别，进行不同的操作啦</p><h3 id="Tuple元组"><a href="#Tuple元组" class="headerlink" title="Tuple元组"></a>Tuple元组</h3><h4 id="定义元组"><a href="#定义元组" class="headerlink" title="定义元组"></a>定义元组</h4><p>元组是<code>TypeScript</code> 中新增的类型，类似于数组。区别在于元组是定长定类型的，于是它特别适合用来实现多值返回</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: [<span class="built_in">string</span>, <span class="built_in">number</span>]; </span><br><span class="line"><span class="comment">// 类型必须匹配且个数必须为2</span></span><br><span class="line"></span><br><span class="line">x = [<span class="string">&#x27;hello&#x27;</span>, <span class="number">10</span>]; <span class="comment">// OK </span></span><br><span class="line">x = [<span class="string">&#x27;hello&#x27;</span>, <span class="number">10</span>,<span class="number">10</span>]; <span class="comment">// Error </span></span><br><span class="line">x = [<span class="number">10</span>, <span class="string">&#x27;hello&#x27;</span>]; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p>注意：元组类型只能表示一个已知元素数量和类型的数组，长度已指定，越界访问会提示错误。如果一个数组中可能有多种类型，数量和类型都不确定，那就直接<code>any[]</code></p><h4 id="元组的解构赋值"><a href="#元组的解构赋值" class="headerlink" title="元组的解构赋值"></a>元组的解构赋值</h4><p>我们可以通过下标的方式来访问元组中的元素，当元组中的元素较多时，这种方式并不是那么便捷。其实元组也是支持解构赋值的：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">employee</span>: [<span class="built_in">number</span>, <span class="built_in">string</span>] = [<span class="number">1</span>, <span class="string">&quot;张三&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> [id, username] = employee;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`id: <span class="subst">$&#123;id&#125;</span>`</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`username: <span class="subst">$&#123;username&#125;</span>`</span>);</span><br></pre></td></tr></table></figure><h4 id="元组的可选元素"><a href="#元组的可选元素" class="headerlink" title="元组的可选元素"></a>元组的可选元素</h4><p>与函数签名类型，在定义元组类型时，也可以通过 <code>?</code> 号来声明元组类型的可选元素，具体的示例如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">optionalTuple</span>: [<span class="built_in">string</span>, <span class="built_in">boolean</span>?];</span><br><span class="line">optionalTuple = [<span class="string">&quot;Semlinker&quot;</span>, <span class="literal">true</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`optionalTuple : <span class="subst">$&#123;optionalTuple&#125;</span>`</span>);</span><br><span class="line">optionalTuple = [<span class="string">&quot;Kakuqo&quot;</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`optionalTuple : <span class="subst">$&#123;optionalTuple&#125;</span>`</span>);</span><br></pre></td></tr></table></figure><p>元组的剩余元素</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">RestTupleType</span> = [<span class="built_in">number</span>, ...<span class="built_in">string</span>[]];</span><br><span class="line"><span class="keyword">let</span> <span class="attr">restTuple</span>: <span class="title class_">RestTupleType</span> = [<span class="number">666</span>, <span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;王五&quot;</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(restTuple[<span class="number">0</span>]); <span class="comment">// 666</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(restTuple[<span class="number">1</span>]); <span class="comment">// &quot;张三&quot;</span></span><br></pre></td></tr></table></figure><p>与函数签名类型类似，可以在元组的最后一个元素使用剩余元素</p><h4 id="只读元组"><a href="#只读元组" class="headerlink" title="只读元组"></a>只读元组</h4><p><code>TypeScript</code>在3.4中引入了对只读元组的新支持，可以为任何元组类型加上 <code>readonly</code> 关键字前缀，以使其成为只读元组。具体的示例如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">point</span>: <span class="keyword">readonly</span> [<span class="built_in">number</span>, <span class="built_in">number</span>] = [<span class="number">10</span>, <span class="number">20</span>];</span><br></pre></td></tr></table></figure><p>在使用 <code>readonly</code> 关键字修饰元组类型之后，任何企图修改元组中元素的操作都会抛出异常</p><h3 id="void"><a href="#void" class="headerlink" title="void"></a>void</h3><p><code>void</code>通常表示函数没有返回值，只能为其赋值它本身和<code>undefined</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="built_in">void</span>; </span><br><span class="line"><span class="keyword">let</span> <span class="attr">b</span>: <span class="built_in">number</span> = a; <span class="comment">// Error</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn2</span>(<span class="params"></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn3</span>(<span class="params"></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>(); <span class="comment">// Error</span></span><br><span class="line"><span class="title function_">fn2</span>(); <span class="comment">// ok</span></span><br><span class="line"><span class="title function_">fn3</span>(); <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><h3 id="never"><a href="#never" class="headerlink" title="never"></a>never</h3><p><code>never</code>类型表示的是那些永不存在的值的类型</p><p>值会永不存在的两种情况：</p><ol><li>一个函数在执行时抛出<strong>异常</strong>，程序中断运行</li><li>函数中执行无限循环代码<strong>死循环</strong></li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异常</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">err</span>(<span class="params">msg: <span class="built_in">string</span></span>): <span class="built_in">never</span> &#123; <span class="comment">// OK</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(msg); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 死循环</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">loopForever</span>(<span class="params"></span>): <span class="built_in">never</span> &#123; <span class="comment">// OK</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>never</code>类型同<code>null</code>和<code>undefined</code>一样，也是任何类型的子类型，也可以赋值给任何类型。</p><p>但是<code>never</code>类型的变量，只能接受<code>never</code>类型的赋值，也就是说除<code>never</code>以为，其他所有类型都不能赋值给<code>never</code>，包括<code>any</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="built_in">never</span>;</span><br><span class="line">a = <span class="number">1</span>; <span class="comment">// Error</span></span><br><span class="line">a = <span class="literal">null</span>; <span class="comment">// Error</span></span><br><span class="line">a = <span class="literal">undefined</span>; <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">b</span>: <span class="built_in">never</span> = (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123; &#125;</span><br><span class="line">&#125;)();</span><br><span class="line">a = b; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><h3 id="any"><a href="#any" class="headerlink" title="any"></a>any</h3><p>在 <code>TypeScript</code> 中，任何类型都可以被归为 <code>any</code> 类型。这让 <code>any</code> 类型成为了类型系统的顶级类型，<code>any</code>类型允许被赋值为任意类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>:<span class="built_in">any</span>;</span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line">a = <span class="string">&#x27;str&#x27;</span>;</span><br><span class="line">a = &#123;&#125;;</span><br><span class="line">a = [];</span><br><span class="line">a = <span class="literal">null</span>;</span><br><span class="line">a = <span class="literal">undefined</span>;</span><br><span class="line">a = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>并且使用<code>any</code>定义的对象允许访问、调用任意属性、方法，但是有没有就不得而知了</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">str</span>:<span class="built_in">any</span> = <span class="string">&#x27;str&#x27;</span>;</span><br><span class="line">str.<span class="property">subStr</span> = <span class="string">&#x27;sub&#x27;</span>;</span><br><span class="line">str.<span class="title function_">setStr</span>(<span class="string">&#x27;newStr&#x27;</span>);</span><br></pre></td></tr></table></figure><p>需要注意的是，<code>any</code>类型有“污染”其他变量的风险</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> obj.<span class="property">name</span>) <span class="comment">// string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">obj2</span>: <span class="built_in">any</span> = obj;</span><br><span class="line">obj2.<span class="property">name</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> obj2.<span class="property">name</span>) <span class="comment">// number</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> obj.<span class="property">name</span>) <span class="comment">// number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>: (<span class="built_in">string</span> | <span class="built_in">number</span>)[] = [<span class="number">1</span>, <span class="string">&#x27;haha&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;xixi&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr) <span class="comment">// [ 1, &#x27;haha&#x27;, 2, &#x27;xixi&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span>:<span class="built_in">any</span> = arr</span><br><span class="line">a[<span class="number">1</span>] = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// [ 1, true, 2, &#x27;xixi&#x27; ]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr)<span class="comment">// [ 1, true, 2, &#x27;xixi&#x27; ]</span></span><br></pre></td></tr></table></figure><p>另外需要注意的是，声明变量时如果不指定类型，或者不直接赋值时，则TS解析器会自动判断变量的类型为any（隐式any）</p><h3 id="unknown"><a href="#unknown" class="headerlink" title="unknown"></a>unknown</h3><p><code>unknown</code>与<code>any</code>一样，所有的其他类型可以分配给<code>unknown</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>:<span class="built_in">unknown</span>;</span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line">a = <span class="literal">true</span>;</span><br><span class="line">a = <span class="string">&#x27;str&#x27;</span>;</span><br></pre></td></tr></table></figure><p><code>unknown</code>与<code>any</code>的最大区别是： 任何类型的值可以赋值给<code>any</code>，同时<code>any</code>类型的值也可以赋值给任何类型。<code>unknown</code> 任何类型的值都可以赋值给它，但它只能赋值给<code>unknown</code>和<code>any</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>:<span class="built_in">unknown</span>;</span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">b</span>:<span class="built_in">string</span> = <span class="string">&#x27;str&#x27;</span>;</span><br><span class="line"></span><br><span class="line">b = a; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p>如果就是要将<code>unknown</code>赋值为其他类型，则可使用以下方式：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> a === <span class="string">&#x27;string&#x27;</span>) b = a</span><br><span class="line"></span><br><span class="line">b = a <span class="keyword">as</span> <span class="built_in">string</span>;</span><br><span class="line">b = &lt;<span class="built_in">string</span>&gt;a;</span><br></pre></td></tr></table></figure><p><code>any</code>有污染的风险而<code>unknown</code>则不必担心</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> obj.<span class="property">name</span>) <span class="comment">// string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">isAny</span>: <span class="built_in">any</span> = obj</span><br><span class="line">isAny.<span class="property">name</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> obj.<span class="property">name</span>) <span class="comment">// number</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> isAny.<span class="property">name</span>) <span class="comment">// number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;李四&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">isUnknown</span>: <span class="built_in">unknown</span>;</span><br><span class="line">isUnknown = obj2;</span><br><span class="line"></span><br><span class="line">isUnknown.<span class="property">name</span> = <span class="number">1</span>; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><h3 id="字面量类型"><a href="#字面量类型" class="headerlink" title="字面量类型"></a>字面量类型</h3><p>在TypeScript中，字面量不仅可以表示值，还可以表示类型。目前TypeScript支持三种字面量类型：字符串、数字、布尔值</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">str</span>: <span class="string">&#x27;this is str&#x27;</span> = <span class="string">&#x27;this is str&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">num</span>: <span class="number">1</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">bool</span>: <span class="literal">false</span> = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>变量<code>str</code>是一个字符串类型，准确来说是一个字符串子类型，它只允许被赋予声明时被指定的值</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">str2</span>:<span class="built_in">string</span> = <span class="string">&#x27;any string&#x27;</span>;</span><br><span class="line">str = str2;</span><br><span class="line">str = <span class="string">&#x27;this is str&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="字符串字面量类型"><a href="#字符串字面量类型" class="headerlink" title="字符串字面量类型"></a>字符串字面量类型</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let str: &#x27;this is str&#x27; = &#x27;this is str&#x27;;</span><br><span class="line">str = &#x27;other&#x27;; // Error</span><br></pre></td></tr></table></figure><p>单看字符串字面量类型好像没啥卵用，但它配合联合类型就非常有用了</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Direction</span> = <span class="string">&#x27;left&#x27;</span> | <span class="string">&#x27;right&#x27;</span> | <span class="string">&#x27;top&#x27;</span> | <span class="string">&#x27;bottom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> move = (<span class="attr">direction</span>: <span class="title class_">Direction</span>, <span class="attr">distance</span>: <span class="built_in">number</span>): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`向<span class="subst">$&#123;direction&#125;</span>，移动了<span class="subst">$&#123;distance&#125;</span>码`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">move</span>(<span class="string">&#x27;top&#x27;</span>, <span class="number">500</span>) <span class="comment">// ok</span></span><br><span class="line"><span class="title function_">move</span>(<span class="string">&#x27;up&#x27;</span>, <span class="number">500</span>) <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p>相较于使用 string 类型，使用字面量类型（组合的联合类型）可以将函数的参数限定为更具体的类型。这不仅提升了程序的可读性，还保证了函数的参数类型，可谓一举两得。</p><h4 id="数字字面量类型及布尔字面量类型"><a href="#数字字面量类型及布尔字面量类型" class="headerlink" title="数字字面量类型及布尔字面量类型"></a>数字字面量类型及布尔字面量类型</h4><p>数字字面量类型和布尔字面量类型与字符串字面量类型类似</p><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举<code>enum</code>，一组带名字的常量的集合，枚举类型可以为一组数值赋予友好的名字，不必关心值，只用关心键（名字）即好</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Gender</span> &#123;</span><br><span class="line">    <span class="title class_">Male</span>,</span><br><span class="line">    <span class="title class_">Female</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">h</span>: &#123; <span class="attr">name</span>: <span class="built_in">string</span>, <span class="attr">gender</span>: <span class="title class_">Gender</span> &#125;;</span><br><span class="line">h = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="title class_">Gender</span>.<span class="property">Male</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(h.<span class="property">gender</span> === <span class="title class_">Gender</span>.<span class="property">Male</span>)</span><br></pre></td></tr></table></figure><h3 id="Number、String、Boolean、Symbol"><a href="#Number、String、Boolean、Symbol" class="headerlink" title="Number、String、Boolean、Symbol"></a>Number、String、Boolean、Symbol</h3><p>首字母大写的 Number、String、Boolean、Symbol 类型是首字母小写的原始类型 number、string、boolean、symbol的包装对象，更准确的说首字母大写的 Number、String、Boolean、Symbol是对象类型。原始类型兼容对象类型，而对象类型不兼容原始类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">str</span>:<span class="built_in">string</span> = <span class="string">&#x27;str&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Str</span>: <span class="title class_">String</span>;</span><br><span class="line"><span class="title class_">Str</span> = str; <span class="comment">// ok</span></span><br><span class="line">str = <span class="title class_">Str</span>; <span class="comment">// 不能将类型“String”分配给类型“string”。“string”是基元，但“String”是包装器对象。如可能首选使用“string”。ts(2322)</span></span><br></pre></td></tr></table></figure><h3 id="object、Object-和"><a href="#object、Object-和" class="headerlink" title="object、Object 和 {}"></a>object、Object 和 {}</h3><p>object首字母小写的，定义的变量，可以接受非原始类型的类型如：数组、对象、函数。而原始类型则不行如：number、string、boolean、null、undefined</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let obj:object</span><br><span class="line"></span><br><span class="line">obj = [] // ok</span><br><span class="line">obj = &#123;&#125; // ok</span><br><span class="line">obj = () =&gt; &#123;&#125; // ok</span><br><span class="line"></span><br><span class="line">obj = 1 // err</span><br><span class="line">obj = &#x27;str&#x27; // err</span><br><span class="line">obj = null // err</span><br><span class="line">obj = undefined // err</span><br></pre></td></tr></table></figure><p>Object首字母大写的，表示JavaScript 中的对象类型，包括原始类型和非原始类型，如number、string、boolean、null、undefined、数组、函数和对象等。如果开启严格模式则不可接受null和undefined</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>:<span class="title class_">Object</span></span><br><span class="line"></span><br><span class="line">obj = <span class="number">1</span></span><br><span class="line">obj = &#123;&#125;</span><br><span class="line">obj = <span class="literal">null</span></span><br><span class="line">obj = <span class="literal">undefined</span></span><br></pre></td></tr></table></figure><p><code>&#123;&#125;</code> 与 <code>Object</code> 的效果几乎一样，即 <code>&#123;&#125;</code> == <code>Object</code>，但 <code>Object</code> 更规范</p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h3><p>每次在声明变量的时候都要写明类型注解，let就不说了，毕竟值会发生改变。但const也要写类型注解，这就显得非常的麻烦。好在TS在多少情况下会根据上下文环境自动推断出类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let str = &#x27;str&#x27; // string</span><br><span class="line">let num = 1 // number</span><br><span class="line">let bool = false // boolean</span><br><span class="line"></span><br><span class="line">const str2 = &#x27;str2&#x27; // string</span><br><span class="line">const num2 = 2 // number</span><br><span class="line">const bool = true // boolean</span><br><span class="line"></span><br><span class="line">function add(a, b) &#123; // a, b number</span><br><span class="line">  return a + b // number</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>在有些情况下，我们自己是知道变量类型，但TS解析器可能不知道，这时就可以使用类型断言</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>:<span class="built_in">unknown</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">b</span>:<span class="built_in">number</span> = a <span class="keyword">as</span> <span class="built_in">number</span></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>:<span class="built_in">number</span> = &lt;<span class="built_in">number</span>&gt;a</span><br></pre></td></tr></table></figure><p>语法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>:xxx = xxx</span><br><span class="line"><span class="keyword">let</span> <span class="attr">y</span>:xxx = x <span class="keyword">as</span> xxx</span><br><span class="line"><span class="keyword">let</span> <span class="attr">z</span>:xxx = &lt;xxx&gt;x</span><br></pre></td></tr></table></figure><h4 id="非空断言"><a href="#非空断言" class="headerlink" title="非空断言"></a>非空断言</h4><p>非空断言可以使用<code>!</code>来告诉TS解析器变量不是<code>null</code>和<code>undefined</code>，这将从类型组合中排除<code>null</code>和<code>undefined</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="literal">null</span> | <span class="literal">undefined</span> | <span class="built_in">string</span></span><br><span class="line">x!.<span class="title function_">toString</span>()</span><br></pre></td></tr></table></figure><h4 id="确定赋值断言"><a href="#确定赋值断言" class="headerlink" title="确定赋值断言"></a>确定赋值断言</h4><p>可以在变量声明后使用<code>!</code>来告诉TS解析器该属性会被明确的赋值</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line"><span class="title function_">initialize</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Variable &#x27;x&#x27; is used before being assigned.(2454)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span> * x); <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">initialize</span>(<span class="params"></span>) &#123;</span><br><span class="line">  x = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这时TS解析器不确定x有没有值，所有报错。同时我们来使用<code>!</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x!: <span class="built_in">number</span>;</span><br><span class="line"><span class="title function_">initialize</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span> * x); <span class="comment">// Ok</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">initialize</span>(<span class="params"></span>) &#123;</span><br><span class="line">  x = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类型拓展"><a href="#类型拓展" class="headerlink" title="类型拓展"></a>类型拓展</h3><p>所有通过 let 或 var 定义的变量、函数的形参、对象的非只读属性，如果满足指定了初始值且未显式添加类型注解的条件，那么它们推断出来的类型就是指定的初始值字面量类型拓宽后的类型，这就是字面量类型拓宽</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;str&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">str2</span>: <span class="string">&#x27;str2&#x27;</span> = <span class="string">&#x27;str2&#x27;</span></span><br><span class="line"></span><br><span class="line">str = str2 <span class="comment">// string</span></span><br><span class="line">str2 = str <span class="comment">// err</span></span><br></pre></td></tr></table></figure><p>也就是说str支持string类型以及其子类型</p><h3 id="类型缩小"><a href="#类型缩小" class="headerlink" title="类型缩小"></a>类型缩小</h3><p>我们可以通过某些操作将变量的类型由一个较为宽泛的集合缩小到相对较小、较明确的集合，这就是 “Type Narrowing”及类型缩小。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span> = (<span class="params">x:<span class="built_in">any</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> x === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x <span class="comment">// string</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> x === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x <span class="comment">// number</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ... <span class="comment">// other</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类型联合"><a href="#类型联合" class="headerlink" title="类型联合"></a>类型联合</h3><p>可以使用<code>|</code>来分割多个类型定义</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">age</span>: <span class="built_in">number</span> | <span class="built_in">string</span>;</span><br><span class="line">age = <span class="number">12</span></span><br><span class="line">age = <span class="string">&#x27;12&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">gender</span>: <span class="string">&#x27;male&#x27;</span> | <span class="string">&#x27;female&#x27;</span></span><br><span class="line">gender = <span class="string">&#x27;male&#x27;</span></span><br><span class="line">gender = <span class="string">&#x27;female&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>给类型取别名，通常用于类型联合</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Gender</span> = <span class="string">&#x27;male&#x27;</span> | <span class="string">&#x27;female&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">gender</span>: <span class="title class_">Gender</span>;</span><br><span class="line">gender = <span class="string">&#x27;male&#x27;</span></span><br><span class="line">gender = <span class="string">&#x27;female&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h3><p>交叉类型可以将多个类型合并为一个类型，使用<code>&amp;</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Age</span> = <span class="built_in">number</span> &amp; <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">age</span>: <span class="title class_">Age</span></span><br></pre></td></tr></table></figure><p>如上把原始类型、字面量类型、函数类型等原始类型合并成交叉类型，并没有什么卵用，因为任何类型都不能满足同时属于多种原始类型，Age是个<code>never</code></p><p>真正有用的是合并多个对象类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Person</span> = &#123; <span class="attr">name</span>: <span class="built_in">string</span> &#125; &amp; &#123; <span class="attr">age</span>: <span class="built_in">number</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">person</span>:<span class="title class_">Person</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果合并的类型之前存在且类型不同则会产生冲突，所以不要定义同属性类型却不同</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="什么是接口？"><a href="#什么是接口？" class="headerlink" title="什么是接口？"></a>什么是接口？</h3><p>接口（interfaces）在面向对象语言中是很重要的一个概念，它是对行为抽象，而具体的行动交给类（classes）去实现（implement）</p><p>TypeScript 中的接口是一个非常灵活的概念，除了可用于[对类的一部分行为进行抽象]以外，也常用于对「对象的形状（Shape）」进行描述</p><p>个人理解接口就是，一系列规范、约束的合集</p><h3 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h3><p>使用<code>interface</code>关键字来定义</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">person</span>:<span class="title class_">Person</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口首字母大写，另外没有配置接口之前，任何多或少属性都是不被允许的，不许严格按照接口的定义实现</p><p>可选和只读属性</p><p>与之前的定义方式相同使用<code>readonly</code>和<code>?</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">name</span>: <span class="built_in">string</span>,</span><br><span class="line">    age?:<span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">person</span>:<span class="title class_">Person</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person.<span class="property">name</span> = <span class="string">&#x27;李四&#x27;</span> <span class="comment">// err 无法为“name”赋值，因为它是只读属性。</span></span><br></pre></td></tr></table></figure><h3 id="任意属性"><a href="#任意属性" class="headerlink" title="任意属性"></a>任意属性</h3><p>当我们想还允许对象中包含其他任意属性，可以使用<strong>索引签名</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">name</span>: <span class="built_in">string</span>,</span><br><span class="line">    age?:<span class="built_in">number</span>,</span><br><span class="line">    [<span class="attr">propName</span>: <span class="built_in">string</span>]: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">person</span>:<span class="title class_">Person</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;male&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，<strong>一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集</strong></p><p>一个接口中只能定义一个任意属性。如果接口中有多个类型的属性，则可以在任意属性中使用联合类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    age?: <span class="built_in">number</span>; <span class="comment">// 这里真实的类型应该为：number | undefined</span></span><br><span class="line">    [<span class="attr">propName</span>: <span class="built_in">string</span>]: <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">tom</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;male&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="鸭式辨型法"><a href="#鸭式辨型法" class="headerlink" title="鸭式辨型法"></a>鸭式辨型法</h3><p>不在乎它是不是鸭子本身，只要它能走路能像鸭子嘎嘎叫，具备鸭子的特性那么认为它就是鸭子。也就是说通过制定规则来判定对象是否实现这个接口</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Duck</span> &#123;</span><br><span class="line">    <span class="attr">echo</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sound</span>(<span class="params">duck: Duck</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(duck.<span class="property">echo</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> duck = &#123; <span class="attr">echo</span>: <span class="string">&#x27;嘎嘎&#x27;</span>, <span class="attr">age</span>: <span class="number">2</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">sound</span>(duck) <span class="comment">// ok</span></span><br><span class="line"><span class="title function_">sound</span>(&#123; <span class="attr">echo</span>: <span class="string">&#x27;嘎嘎&#x27;</span>, <span class="attr">age</span>: <span class="number">2</span> &#125;) <span class="comment">// err</span></span><br></pre></td></tr></table></figure><p>问题来了为什么，使用一个变量接受后，调用<code>sound</code>传入参数没问题而直接<code>sound(&#123; echo: &#39;嘎嘎&#39;, age: 2 &#125;)</code>就有问题？那是因为使用变量接受后不会经过额外的属性检查，<code>duck = duck</code>，根据类型的兼容所以没问题，而<code>sound(&#123; echo: &#39;嘎嘎&#39;, age: 2 &#125;)</code>则会直接使用Duck接口的属性检查。参照<strong>鸭式辨型法</strong>，因为都具有<code>echo</code>属性，所以被认定为两个相同，故而可以用此法来绕开多余的类型检查</p><p>简单来说就是让TS解析器不关注对象的类型标识，而是注重对象的属性方法是否匹配。</p><h3 id="绕开额外属性检查的方式"><a href="#绕开额外属性检查的方式" class="headerlink" title="绕开额外属性检查的方式"></a>绕开额外属性检查的方式</h3><p>除了鸭式辨型法，还可以通过其他的方式绕开额外属性检查的方式</p><h4 id="类型断言-1"><a href="#类型断言-1" class="headerlink" title="类型断言"></a>类型断言</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Duck</span> &#123;</span><br><span class="line">    <span class="attr">echo</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sound</span>(<span class="params">duck: Duck</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(duck.<span class="property">echo</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">sound</span>(&#123; <span class="attr">echo</span>: <span class="string">&#x27;嘎嘎&#x27;</span>, <span class="attr">age</span>: <span class="number">2</span> &#125; <span class="keyword">as</span> <span class="title class_">Duck</span>) <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>这时TS解析器不会再进行额外的属性检查</p><h4 id="索引签名"><a href="#索引签名" class="headerlink" title="索引签名"></a>索引签名</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Duck</span> &#123;</span><br><span class="line">    <span class="attr">echo</span>: <span class="built_in">string</span>,</span><br><span class="line">    [<span class="attr">propName</span>: <span class="built_in">string</span>]:<span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sound</span>(<span class="params">duck: Duck</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(duck.<span class="property">echo</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">sound</span>(&#123; <span class="attr">echo</span>: <span class="string">&#x27;嘎嘎&#x27;</span>, <span class="attr">age</span>: <span class="number">2</span> &#125;) <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><h3 id="接口和类型别名的区别"><a href="#接口和类型别名的区别" class="headerlink" title="接口和类型别名的区别"></a>接口和类型别名的区别</h3><p>实际上，在大多数的情况下使用接口类型和类型别名的效果等价，但还是有些不同</p><p>接口是用于描述对象的，而类型别名则可以描述任何类型，包括对象</p><h4 id="对象和函数"><a href="#对象和函数" class="headerlink" title="对象和函数"></a>对象和函数</h4><p>两者都可以用来描述对象或函数的类型，但是语法不同</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">SetPoint</span> &#123;</span><br><span class="line">  (<span class="attr">x</span>: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型别名</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Point</span> = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">SetPoint</span> = <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure><h4 id="其他类型"><a href="#其他类型" class="headerlink" title="其他类型"></a>其他类型</h4><p>与接口不同，类型别名还可以用于其他类型，如基本类型（原始值）、联合类型、元组</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// primitive</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Name</span> = <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// object</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PartialPointX</span> = &#123; <span class="attr">x</span>: <span class="built_in">number</span>; &#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PartialPointY</span> = &#123; <span class="attr">y</span>: <span class="built_in">number</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// union</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PartialPoint</span> = <span class="title class_">PartialPointX</span> | <span class="title class_">PartialPointY</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tuple</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Data</span> = [<span class="built_in">number</span>, <span class="built_in">string</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// dom</span></span><br><span class="line"><span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">type</span> B = <span class="keyword">typeof</span> div;</span><br></pre></td></tr></table></figure><h4 id="多次定义"><a href="#多次定义" class="headerlink" title="多次定义"></a>多次定义</h4><p>与类型别名不同，接口可以定义多次，会被自动合并为单个接口</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Point</span> &#123; <span class="attr">x</span>: <span class="built_in">number</span>; &#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Point</span> &#123; <span class="attr">y</span>: <span class="built_in">number</span>; &#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">point</span>: <span class="title class_">Point</span> = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;;</span><br></pre></td></tr></table></figure><h4 id="相互拓展"><a href="#相互拓展" class="headerlink" title="相互拓展"></a>相互拓展</h4><p>两者的扩展方式不同，但并不互斥。接口可以扩展类型别名，同理，类型别名也可以扩展接口。接口的扩展就是继承，通过 <code>extends</code> 来实现。类型别名的扩展就是交叉类型，通过 <code>&amp;</code> 来实现</p><ul><li><p>接口拓展接口</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">PointX</span> &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Point</span> <span class="keyword">extends</span> <span class="title class_">PointX</span> &#123;</span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>类型别名拓展类型别名</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PointX</span> = &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Point</span> = <span class="title class_">PointX</span> &amp; &#123;</span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接口拓展类型别名</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">PointX</span> = &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Point</span> <span class="keyword">extends</span> <span class="title class_">PointX</span> &#123;</span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>类型别名拓展接口</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">PointX</span> &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Point</span> = <span class="title class_">PointX</span> &amp; &#123;</span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="什么是泛型？"><a href="#什么是泛型？" class="headerlink" title="什么是泛型？"></a>什么是泛型？</h3><p>从例子入手，如果我们想定义一个函数，函数的参数可以是任意值且函数的返回值就是参数的类型，可以这样写</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">identity</span> = (<span class="params">arg</span>) =&gt; arg</span><br></pre></td></tr></table></figure><p>但是这时<code>arg</code>的类型为<code>any</code>，这个<code>any</code>很可能会对我们造成麻烦，这时不要这个<code>any</code>也要写类型别名</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> idBoolean = <span class="function">(<span class="params">arg: <span class="built_in">boolean</span></span>) =&gt;</span> <span class="built_in">boolean</span></span><br><span class="line"><span class="keyword">type</span> idNumber = <span class="function">(<span class="params">arg: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span></span><br><span class="line"><span class="keyword">type</span> idString = <span class="function">(<span class="params">arg: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">string</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这就显得非常的操蛋，这时使用泛型就可以解决问题了</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> identity = &lt;T&gt;(<span class="attr">arg</span>: T): <span class="function"><span class="params">T</span> =&gt;</span> arg</span><br></pre></td></tr></table></figure><p>泛型的本质是参数化类型，即将类型作为参数传递给函数或类</p><p>其中 <code>T</code> 代表 <strong>Type</strong>，在定义泛型时通常用作第一个类型变量名称。但实际上 <code>T</code> 可以用任何有效名称代替。除了 <code>T</code> 之外，以下是常见泛型变量代表的意思:</p><ul><li>K(key)：表示对象的键</li><li>V(value)：表示对象中的值</li><li>E(Element)：表示元素</li></ul><p>另外泛型可以定义多个</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> identity = &lt;T, U&gt;<span class="function">(<span class="params">value: T, str: U</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`value:<span class="subst">$&#123;value&#125;</span>,str:<span class="subst">$&#123;str&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">identity&lt;<span class="built_in">number</span>, <span class="built_in">string</span>&gt;(<span class="number">1</span>, <span class="string">&#x27;2&#x27;</span>)</span><br></pre></td></tr></table></figure><p>我们还可以省略尖括号</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> identity = &lt;T, U&gt;<span class="function">(<span class="params">value: T, str: U</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`value:<span class="subst">$&#123;value&#125;</span>,str:<span class="subst">$&#123;str&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">identity</span>(<span class="number">1</span>, <span class="string">&#x27;2&#x27;</span>)</span><br></pre></td></tr></table></figure><p>TS解析器会根据传入的实参自动判断和传递类型</p><h3 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h3><p>泛型约束是指对泛型类型参数进行限制</p><p>当我们直接访问泛型类型上的属性</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> identity = &lt;T&gt;(<span class="attr">arg</span>: T): <span class="function"><span class="params">T</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">length</span>) <span class="comment">// err 类型“T”上不存在属性“length”</span></span><br><span class="line">    <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同于 any，不管使用泛型类型的什么属性或者方法都会报错（除非这个属性和方法是所有集合共有的）。这时可以用到<strong>类型约束</strong>，使用<code>extends</code>关键字可以做到</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Lengthwise</span> &#123;</span><br><span class="line">    <span class="attr">length</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> identity = &lt;T <span class="keyword">extends</span> <span class="title class_">Lengthwise</span>&gt;(<span class="attr">arg</span>: T): <span class="function"><span class="params">T</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">length</span>)</span><br><span class="line">    <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型工具类型"><a href="#泛型工具类型" class="headerlink" title="泛型工具类型"></a>泛型工具类型</h3><p>TS内置了一些常用的工具类型，比如 Partial、Required、Readonly、Record 和 ReturnType 等。它们可以帮助我们便捷地定义和操作类型</p><h4 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h4><p><code>typeof</code> 的主要用途是在类型上下文中获取变量或者属性的类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">sem</span>: <span class="title class_">Person</span> = &#123; <span class="attr">name</span>: <span class="string">&quot;semlinker&quot;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Sem</span> = <span class="keyword">typeof</span> sem; <span class="comment">// type Sem = Person</span></span><br></pre></td></tr></table></figure><p>现在可以使用Sem类型了</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">lolo</span>: <span class="title class_">Sem</span> = &#123; <span class="attr">name</span>: <span class="string">&quot;lolo&quot;</span>, <span class="attr">age</span>: <span class="number">5</span> &#125;</span><br></pre></td></tr></table></figure><p><code>typeof</code>也可以用于嵌套对象</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Message</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;jimmy&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">address</span>: &#123;</span><br><span class="line">      <span class="attr">province</span>: <span class="string">&#x27;四川&#x27;</span>,</span><br><span class="line">      <span class="attr">city</span>: <span class="string">&#x27;成都&#x27;</span>   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> message = <span class="keyword">typeof</span> <span class="title class_">Message</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> type message = &#123;</span></span><br><span class="line"><span class="comment">    name: string;</span></span><br><span class="line"><span class="comment">    age: number;</span></span><br><span class="line"><span class="comment">    address: &#123;</span></span><br><span class="line"><span class="comment">        province: string;</span></span><br><span class="line"><span class="comment">        city: string;</span></span><br><span class="line"><span class="comment">    &#125;;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>typeof</code>还可以用来获取函数表达式</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">toArray</span>(<span class="params">x: <span class="built_in">number</span></span>): <span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> [x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Func</span> = <span class="keyword">typeof</span> toArray; <span class="comment">// -&gt; (x: number) =&gt; number[]</span></span><br></pre></td></tr></table></figure><h4 id="keyof"><a href="#keyof" class="headerlink" title="keyof"></a>keyof</h4><p><code>keyof</code> 操作符是在 TypeScript 2.1 版本引入的，该操作符可以用于获取某种类型的所有键，其返回类型是联合类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">K1</span> = keyof <span class="title class_">Person</span>; <span class="comment">// &quot;name&quot; | &quot;age&quot;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">K2</span> = keyof <span class="title class_">Person</span>[]; <span class="comment">// &quot;length&quot; | &quot;toString&quot; | &quot;pop&quot; | &quot;push&quot; | &quot;concat&quot; | &quot;join&quot; </span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">K3</span> = keyof &#123; [<span class="attr">x</span>: <span class="built_in">string</span>]: <span class="title class_">Person</span> &#125;;  <span class="comment">// string | number</span></span><br></pre></td></tr></table></figure><p>keyof也支持基本数据类型</p><h4 id="in"><a href="#in" class="headerlink" title="in"></a>in</h4><p><code>in</code> 用来遍历枚举类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Keys</span> = <span class="string">&quot;a&quot;</span> | <span class="string">&quot;b&quot;</span> | <span class="string">&quot;c&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Obj</span> =  &#123;</span><br><span class="line">  [p <span class="keyword">in</span> <span class="title class_">Keys</span>]: <span class="built_in">any</span></span><br><span class="line">&#125; <span class="comment">// -&gt; &#123; a: any, b: any, c: any &#125;</span></span><br></pre></td></tr></table></figure><h4 id="infer"><a href="#infer" class="headerlink" title="infer"></a>infer</h4><p>在条件类型语句中，可以用 <code>infer</code> 声明一个类型变量并且对它进行使用</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ReturnType</span>&lt;T&gt; = T <span class="keyword">extends</span> (</span><br><span class="line">  ...<span class="attr">args</span>: <span class="built_in">any</span>[]</span><br><span class="line">) =&gt; infer R ? R : <span class="built_in">any</span>;</span><br></pre></td></tr></table></figure><p>以上代码中 <code>infer R</code> 就是声明一个变量来承载传入函数签名的返回值类型，简单说就是用它取到函数返回值的类型方便之后使用</p><h4 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h4><p>有时候我们定义的泛型不想过于灵活或者说想继承某些类等，可以通过 extends 关键字添加泛型约束</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Lengthwise</span> &#123;</span><br><span class="line">  <span class="attr">length</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> loggingIdentity&lt;T <span class="keyword">extends</span> <span class="title class_">Lengthwise</span>&gt;(<span class="attr">arg</span>: T): T &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">length</span>);</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h4><p>索引类型包含两个主要的类型：字符串索引类型和数字索引类型。字符串索引类型允许使用字符串作为键来访问对象属性，数字索引类型允许使用数字作为键来访问数组元素</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">    [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">string</span> | <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">person</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;male&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person.<span class="property">height</span> = <span class="number">180</span></span><br></pre></td></tr></table></figure><p>通过字符串索引类型，我们在<code>Person</code>类型中添加了一个任意属性，可以接受字符串类型和数字类型的值。这意味着我们可以给<code>Person</code>对象添加任意属性，并且这些属性必须是字符串或数字类型的值。</p><p>索引类型的优点是，可以编写更加通用的类型定义，应用于不同类型的数据结构，从而提高代码的可复用性和易维护性。但是，使用索引类型需要小心，因为它可能会导致运行时错误，需要在编程时特别注意。</p><h4 id="类型映射"><a href="#类型映射" class="headerlink" title="类型映射"></a>类型映射</h4><p>映射类型是一种根据旧类型创建新类型的便捷方式</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们可以通过+/-来指定添加还是删除</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">OptionalTestInterface</span>&lt;T&gt; = &#123;</span><br><span class="line">  [p <span class="keyword">in</span> keyof T]+?:T[p]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> newTestInterface = <span class="title class_">OptionalTestInterface</span>&lt;<span class="title class_">TestInterface</span>&gt;</span><br><span class="line"><span class="comment">// type newTestInterface = &#123;</span></span><br><span class="line"><span class="comment">//    name?:string,</span></span><br><span class="line"><span class="comment">//    age?:number</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><h4 id="Partial"><a href="#Partial" class="headerlink" title="Partial"></a>Partial</h4><p>将类型的属性变成可选</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">UserInfo</span> &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// error：Property &#x27;id&#x27; is missing in type &#x27;&#123; name: string; &#125;&#x27; but required in type &#x27;UserInfo&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">xiaoming</span>: <span class="title class_">UserInfo</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;xiaoming&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NewUserInfo</span> = <span class="title class_">Partial</span>&lt;<span class="title class_">UserInfo</span>&gt;;ty</span><br><span class="line"><span class="keyword">const</span> <span class="attr">xiaohong</span>: <span class="title class_">NewUserInfo</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;xiaohong&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Partial</span>&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]?: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在以上代码中，首先通过 <code>keyof T</code> 拿到 <code>T</code> 的所有属性名，然后使用 <code>in</code> 进行遍历，将值赋给 <code>P</code>，最后通过 <code>T[P]</code> 取得相应的属性值的类。中间的 <code>?</code> 号，用于将所有属性变为可选。</p><p>注意：<code>Partial&lt;T&gt;</code> 有个局限性，就是只支持处理第一层的属性，如果要处理多层，可以自己实现</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">DeepPartial</span>&lt;T&gt; = &#123;</span><br><span class="line">     <span class="comment">// 如果是 object，则递归类型</span></span><br><span class="line">    [U <span class="keyword">in</span> keyof T]?: T[U] <span class="keyword">extends</span> <span class="built_in">object</span></span><br><span class="line">      ? <span class="title class_">DeepPartial</span>&lt;T[U]&gt;</span><br><span class="line">      : T[U]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PartialedWindow</span> = <span class="title class_">DeepPartial</span>&lt;T&gt;; <span class="comment">// 现在T上所有属性都变成了可选啦</span></span><br></pre></td></tr></table></figure><h4 id="Required"><a href="#Required" class="headerlink" title="Required"></a>Required</h4><p>将类型的属性变成必选</p><p>实现</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Required</span>&lt;T&gt; = &#123; </span><br><span class="line">    [P <span class="keyword">in</span> keyof T]-?: T[P] </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中 <code>-?</code> 是代表移除 <code>?</code> 这个 modifier 的标识。也就是说属性现在为必选了</p><h4 id="Readonly"><a href="#Readonly" class="headerlink" title="Readonly"></a>Readonly</h4><p>将某个类型所有属性变为只读属性，也就意味着这些属性不能被重新赋值</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Todo</span> &#123;</span><br><span class="line"> <span class="attr">title</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">todo</span>: <span class="title class_">Readonly</span>&lt;<span class="title class_">Todo</span>&gt; = &#123;</span><br><span class="line"> <span class="attr">title</span>: <span class="string">&quot;Delete inactive users&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">todo.<span class="property">title</span> = <span class="string">&quot;Hello&quot;</span>; <span class="comment">// Error: cannot reassign a readonly property</span></span><br></pre></td></tr></table></figure><p>实现</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Readonly</span>&lt;T&gt; = &#123;</span><br><span class="line"> <span class="keyword">readonly</span> [P <span class="keyword">in</span> keyof T]: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Pick"><a href="#Pick" class="headerlink" title="Pick"></a>Pick</h4><p>从某个类型中挑出一些属性出来</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Todo</span> &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">description</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">completed</span>: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TodoPreview</span> = <span class="title class_">Pick</span>&lt;<span class="title class_">Todo</span>, <span class="string">&quot;title&quot;</span> | <span class="string">&quot;completed&quot;</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">todo</span>: <span class="title class_">TodoPreview</span> = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&quot;Clean room&quot;</span>,</span><br><span class="line">  <span class="attr">completed</span>: <span class="literal">false</span>,ty</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实现</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Pick</span>&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123;</span><br><span class="line">    [P <span class="keyword">in</span> K]: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Record"><a href="#Record" class="headerlink" title="Record"></a>Record</h4><p>将一个类型中的属性转换成另一个类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">PageInfo</span> &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Page</span> = <span class="string">&quot;home&quot;</span> | <span class="string">&quot;about&quot;</span> | <span class="string">&quot;contact&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">x</span>: <span class="title class_">Record</span>&lt;<span class="title class_">Page</span>, <span class="title class_">PageInfo</span>&gt; = &#123;</span><br><span class="line">  <span class="attr">about</span>: &#123; <span class="attr">title</span>: <span class="string">&quot;about&quot;</span> &#125;,</span><br><span class="line">  <span class="attr">contact</span>: &#123; <span class="attr">title</span>: <span class="string">&quot;contact&quot;</span> &#125;,</span><br><span class="line">  <span class="attr">home</span>: &#123; <span class="attr">title</span>: <span class="string">&quot;home&quot;</span> &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实现</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Record</span>&lt;K <span class="keyword">extends</span> keyof <span class="built_in">any</span>, T&gt; = &#123;</span><br><span class="line">    [P <span class="keyword">in</span> K]: T;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="ReturnType"><a href="#ReturnType" class="headerlink" title="ReturnType"></a>ReturnType</h4><p>用来得到一个函数的返回值类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Func</span> = <span class="function">(<span class="params">value: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">foo</span>: <span class="title class_">ReturnType</span>&lt;<span class="title class_">Func</span>&gt; = <span class="string">&quot;1&quot;</span>;</span><br></pre></td></tr></table></figure><p><code>ReturnType</code>获取到 <code>Func</code> 的返回值类型为 <code>string</code>，所以，<code>foo</code> 也就只能被赋值为字符串了</p><p>实现</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ReturnType</span>&lt;T <span class="keyword">extends</span> (...<span class="attr">args</span>: <span class="built_in">any</span>[]) =&gt; <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> (</span><br><span class="line">  ...<span class="attr">args</span>: <span class="built_in">any</span>[]</span><br><span class="line">) =&gt; infer R</span><br><span class="line">  ? R</span><br><span class="line">  : <span class="built_in">any</span>;</span><br></pre></td></tr></table></figure><h4 id="Exclude"><a href="#Exclude" class="headerlink" title="Exclude"></a>Exclude</h4><p>将某个类型中属于另一个的类型移除掉</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">T0</span> = <span class="title class_">Exclude</span>&lt;<span class="string">&quot;a&quot;</span> | <span class="string">&quot;b&quot;</span> | <span class="string">&quot;c&quot;</span>, <span class="string">&quot;a&quot;</span>&gt;; <span class="comment">// &quot;b&quot; | &quot;c&quot;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">Exclude</span>&lt;<span class="string">&quot;a&quot;</span> | <span class="string">&quot;b&quot;</span> | <span class="string">&quot;c&quot;</span>, <span class="string">&quot;a&quot;</span> | <span class="string">&quot;b&quot;</span>&gt;; <span class="comment">// &quot;c&quot;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = <span class="title class_">Exclude</span>&lt;<span class="built_in">string</span> | <span class="built_in">number</span> | (<span class="function">() =&gt;</span> <span class="built_in">void</span>), <span class="title class_">Function</span>&gt;; <span class="comment">// string | number</span></span><br></pre></td></tr></table></figure><p>实现</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Exclude</span>&lt;T, U&gt; = T <span class="keyword">extends</span> U ? <span class="built_in">never</span> : T;</span><br></pre></td></tr></table></figure><h4 id="Extract"><a href="#Extract" class="headerlink" title="Extract"></a>Extract</h4><p>从一个类型中提却另一个类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">T0</span> = <span class="title class_">Extract</span>&lt;<span class="string">&quot;a&quot;</span> | <span class="string">&quot;b&quot;</span> | <span class="string">&quot;c&quot;</span>, <span class="string">&quot;a&quot;</span> | <span class="string">&quot;f&quot;</span>&gt;; <span class="comment">// &quot;a&quot;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">Extract</span>&lt;<span class="built_in">string</span> | <span class="built_in">number</span> | (<span class="function">() =&gt;</span> <span class="built_in">void</span>), <span class="title class_">Function</span>&gt;; <span class="comment">// () =&gt;void</span></span><br></pre></td></tr></table></figure><p>实现</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Extract</span>&lt;T, U&gt; = T <span class="keyword">extends</span> U ? T : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure><h4 id="Omit"><a href="#Omit" class="headerlink" title="Omit"></a>Omit</h4><p><code>Omit&lt;T, K extends keyof any&gt;</code> 的作用是使用 <code>T</code> 类型中除了 <code>K</code> 类型的所有属性，来构造一个新的类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Todo</span> &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">description</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">completed</span>: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TodoPreview</span> = <span class="title class_">Omit</span>&lt;<span class="title class_">Todo</span>, <span class="string">&quot;description&quot;</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">todo</span>: <span class="title class_">TodoPreview</span> = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&quot;Clean room&quot;</span>,</span><br><span class="line">  <span class="attr">completed</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实现</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Omit</span>&lt;T, K <span class="keyword">extends</span> keyof <span class="built_in">any</span>&gt; = <span class="title class_">Pick</span>&lt;T, <span class="title class_">Exclude</span>&lt;keyof T, K&gt;&gt;;</span><br></pre></td></tr></table></figure><h4 id="NonNullable"><a href="#NonNullable" class="headerlink" title="NonNullable"></a>NonNullable</h4><p>过滤类型中的 <code>null</code> 及 <code>undefined</code> 类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">T0</span> = <span class="title class_">NonNullable</span>&lt;<span class="built_in">string</span> | <span class="built_in">number</span> | <span class="literal">undefined</span>&gt;; <span class="comment">// string | number</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">NonNullable</span>&lt;<span class="built_in">string</span>[] | <span class="literal">null</span> | <span class="literal">undefined</span>&gt;; <span class="comment">// string[]</span></span><br></pre></td></tr></table></figure><p>实现</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">NonNullable</span>&lt;T&gt; = T extendsnull | <span class="literal">undefined</span> ? <span class="built_in">never</span> : T;</span><br></pre></td></tr></table></figure><h4 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a>Parameters</h4><p>用于获得函数的参数类型组成的元组类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A = <span class="title class_">Parameters</span>&lt;<span class="function">() =&gt;</span><span class="built_in">void</span>&gt;; <span class="comment">// []</span></span><br><span class="line"><span class="keyword">type</span> B = <span class="title class_">Parameters</span>&lt;typeofArray.<span class="property">isArray</span>&gt;; <span class="comment">// [any]</span></span><br><span class="line"><span class="keyword">type</span> C = <span class="title class_">Parameters</span>&lt;typeofparseInt&gt;; <span class="comment">// [string, (number | undefined)?]</span></span><br><span class="line"><span class="keyword">type</span> D = <span class="title class_">Parameters</span>&lt;typeofMath.<span class="property">max</span>&gt;; <span class="comment">// number[]</span></span><br></pre></td></tr></table></figure><p>实现</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Parameters</span>&lt;T <span class="keyword">extends</span> (...<span class="attr">args</span>: <span class="built_in">any</span>) =&gt; <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> (...<span class="attr">args</span>: infer P) =&gt; <span class="built_in">any</span></span><br><span class="line">? P : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure><h2 id="tsconfig-json"><a href="#tsconfig-json" class="headerlink" title="tsconfig.json"></a>tsconfig.json</h2><h3 id="tsconfig-json介绍"><a href="#tsconfig-json介绍" class="headerlink" title="tsconfig.json介绍"></a>tsconfig.json介绍</h3><p>tsconfig.json 是 TypeScript 项目的配置文件。如果一个目录下存在一个 tsconfig.json 文件，那么往往意味着这个目录就是 TypeScript 项目的根目录。</p><p>tsconfig.json 包含 TypeScript 编译的相关配置，通过更改编译配置项，我们可以让 TypeScript 编译出 ES6、ES5的代码。</p><h3 id="compilerOptions-选项"><a href="#compilerOptions-选项" class="headerlink" title="compilerOptions 选项"></a>compilerOptions 选项</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">/* 基本选项 */</span></span><br><span class="line">    <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;es5&quot;</span><span class="punctuation">,</span> <span class="comment">// 指定 ECMAScript 目标版本: &#x27;ES3&#x27; (default), &#x27;ES5&#x27;, &#x27;ES6&#x27;/&#x27;ES2015&#x27;, &#x27;ES2016&#x27;, &#x27;ES2017&#x27;, or &#x27;ESNEXT&#x27;</span></span><br><span class="line">    <span class="attr">&quot;module&quot;</span><span class="punctuation">:</span> <span class="string">&quot;commonjs&quot;</span><span class="punctuation">,</span> <span class="comment">// 指定使用模块: &#x27;commonjs&#x27;, &#x27;amd&#x27;, &#x27;system&#x27;, &#x27;umd&#x27; or &#x27;es2015&#x27;</span></span><br><span class="line">    <span class="attr">&quot;lib&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="comment">// 指定要包含在编译中的库文件</span></span><br><span class="line">    <span class="attr">&quot;allowJs&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 允许编译 javascript 文件</span></span><br><span class="line">    <span class="attr">&quot;checkJs&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 报告 javascript 文件中的错误</span></span><br><span class="line">    <span class="attr">&quot;jsx&quot;</span><span class="punctuation">:</span> <span class="string">&quot;preserve&quot;</span><span class="punctuation">,</span> <span class="comment">// 指定 jsx 代码的生成: &#x27;preserve&#x27;, &#x27;react-native&#x27;, or &#x27;react&#x27;</span></span><br><span class="line">    <span class="attr">&quot;declaration&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 生成相应的 &#x27;.d.ts&#x27; 文件</span></span><br><span class="line">    <span class="attr">&quot;sourceMap&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 生成相应的 &#x27;.map&#x27; 文件</span></span><br><span class="line">    <span class="attr">&quot;outFile&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./&quot;</span><span class="punctuation">,</span> <span class="comment">// 将输出文件合并为一个文件</span></span><br><span class="line">    <span class="attr">&quot;outDir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./&quot;</span><span class="punctuation">,</span> <span class="comment">// 指定输出目录</span></span><br><span class="line">    <span class="attr">&quot;rootDir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./&quot;</span><span class="punctuation">,</span> <span class="comment">// 用来控制输出目录结构 --outDir.</span></span><br><span class="line">    <span class="attr">&quot;removeComments&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 删除编译后的所有的注释</span></span><br><span class="line">    <span class="attr">&quot;noEmit&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 不生成输出文件</span></span><br><span class="line">    <span class="attr">&quot;importHelpers&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 从 tslib 导入辅助工具函数</span></span><br><span class="line">    <span class="attr">&quot;isolatedModules&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 将每个文件做为单独的模块 （与 &#x27;ts.transpileModule&#x27; 类似）.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 严格的类型检查选项 */</span></span><br><span class="line">    <span class="attr">&quot;strict&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 启用所有严格类型检查选项</span></span><br><span class="line">    <span class="attr">&quot;noImplicitAny&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 在表达式和声明上有隐含的 any类型时报错</span></span><br><span class="line">    <span class="attr">&quot;strictNullChecks&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 启用严格的 null 检查</span></span><br><span class="line">    <span class="attr">&quot;noImplicitThis&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 当 this 表达式值为 any 类型的时候，生成一个错误</span></span><br><span class="line">    <span class="attr">&quot;alwaysStrict&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 以严格模式检查每个模块，并在每个文件里加入 &#x27;use strict&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 额外的检查 */</span></span><br><span class="line">    <span class="attr">&quot;noUnusedLocals&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 有未使用的变量时，抛出错误</span></span><br><span class="line">    <span class="attr">&quot;noUnusedParameters&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 有未使用的参数时，抛出错误</span></span><br><span class="line">    <span class="attr">&quot;noImplicitReturns&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 并不是所有函数里的代码都有返回值时，抛出错误</span></span><br><span class="line">    <span class="attr">&quot;noFallthroughCasesInSwitch&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 模块解析选项 */</span></span><br><span class="line">    <span class="attr">&quot;moduleResolution&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node&quot;</span><span class="punctuation">,</span> <span class="comment">// 选择模块解析策略： &#x27;node&#x27; (Node.js) or &#x27;classic&#x27; (TypeScript pre-1.6)</span></span><br><span class="line">    <span class="attr">&quot;baseUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./&quot;</span><span class="punctuation">,</span> <span class="comment">// 用于解析非相对模块名称的基目录</span></span><br><span class="line">    <span class="attr">&quot;paths&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="comment">// 模块名到基于 baseUrl 的路径映射的列表</span></span><br><span class="line">    <span class="attr">&quot;rootDirs&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="comment">// 根文件夹列表，其组合内容表示项目运行时的结构内容</span></span><br><span class="line">    <span class="attr">&quot;typeRoots&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="comment">// 包含类型声明的文件列表</span></span><br><span class="line">    <span class="attr">&quot;types&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="comment">// 需要包含的类型声明文件名列表</span></span><br><span class="line">    <span class="attr">&quot;allowSyntheticDefaultImports&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 允许从没有设置默认导出的模块中默认导入。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Source Map Options */</span></span><br><span class="line">    <span class="attr">&quot;sourceRoot&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./&quot;</span><span class="punctuation">,</span> <span class="comment">// 指定调试器应该找到 TypeScript 文件而不是源文件的位置</span></span><br><span class="line">    <span class="attr">&quot;mapRoot&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./&quot;</span><span class="punctuation">,</span> <span class="comment">// 指定调试器应该找到映射文件而不是生成文件的位置</span></span><br><span class="line">    <span class="attr">&quot;inlineSourceMap&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件</span></span><br><span class="line">    <span class="attr">&quot;inlineSources&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 其他选项 */</span></span><br><span class="line">    <span class="attr">&quot;experimentalDecorators&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 启用装饰器</span></span><br><span class="line">    <span class="attr">&quot;emitDecoratorMetadata&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span> <span class="comment">// 为装饰器提供元数据的支持</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> WEB前端 </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
